# Pentester-Toolchain
![alt text](https://github.com/ngimb64/Pentester-Toolchain/blob/main/PentesterToolchain.png?raw=true)


## **Notice**
> This tool may be used for legal purposes only.<br>
> Users take full responsibility for any actions performed using this tool.<br>
> The author accepts no liability for damage caused by this tool.<br>
> If these terms are not acceptable to you, then do not use this tool.


## Purpose
Pentester Toolchain is pentesters templating system for automating toolchains for reconnaissance and
other purposes. It enables pentesters without coding skills to automate commonly used tools and
custom programs while utilizing parallel processing to run scans on multiple hosts simultaneously,
save the output, and convert to markdown in a reporting friendly fashion.


## Features
- easy to use and understand how to use
- simple yaml config file to easily configure fully customizable toolchains of system binaries and custom programs
- parallel host scanning with multiprocessing
- ping scan integration and reactive regex system to execute toolchains based on open ports from nmap output
- ability to skip port scanning and automate toolchains on ports of existing targets
- reporting friendly markdown support


## Prereqs
Written in Python 3.10.6 for Kali Linux Debian-based OS


## Installation
- Run the setup.py script to build a virtual environment and install any external packages in the created venv.

> Examples:<br> 
>       &emsp;&emsp;- Linux:  `python3 setup.py venv`

- Once virtual env is built traverse to the bin directory in the environment folder just created.
- In the venv/bin directory, execute `source activate` to activate the virtual environment.
- If for some reason issues are experienced with the setup script, the alternative is to manually create an environment, activate it, then run pip install -r packages.txt in project root (direct path reference to venv pip may be necessary).
- To exit from the virtual environment when finished, execute `deactivate`.


## How to use
Once prerequisites have been met and installation is complete, follow the instructions in the
instructions.yml file; which are mapped to the config.yml default script file to provide examples.
If customization is desired, make a copy of the default config.yml or the blank.yml file to start from scratch.<br><br>
Once the configuration file is set, simply run:<br>
`python3 pentester_toolchain.py <config_file>`

If root permissions are needed for associated tools, run:<br>
`sudo ./venv/bin/python3 pentester_toolchain.py <config_file>`

If a config file arg is not provided the user will be asked for one when the program starts.<br>

**Important Note**:  Depending on the number of available cores on the system, processes can temporarily hang
on occasion. To mitigate this, I recommended hitting enter around every five minutes to reactivate
the hanging process. At times the program will exit quickly without fully executing, which is simply
fixed by running the program again until it catches. I'm working on a fix for both minor issues, but
for now the tool still has a lot of value to provide and works great if the few small quirks are understood.


## Output format
Generate output is organized by host in following order with handler output mapped identical to [Supported Service Ports](#supported-service-ports):
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;Nmap<br>
> Output -> host -> TCP_Handlers<br>
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;UDP_Handlers<br>
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;TCP_UDP_Handlers<br>

Note: Tools like gobuster can create extra directories inside the project folder, simply delete them when finished


## Supported Service Ports

### TCP Ports

---
20, 21 - FTP <br>
22 - SSH <br>
23 - Telnet <br>
25, 465, 587, 2525 - SMTP <br>
43 - Whois <br>
79 - Finger <br>
80, 443, 8080, 8443 - HTTP/HTTPS <br>
110, 995 - Pop3/Pop3 over TLS <br>
113 - Ident <br>
119, 433 - NNTP/NNTPS (Network News Transport Protocol) <br>
143, 993 - IMAP/IMAP over TLS <br>
199 - SNMP Smux <br>
264 - Checkpoint-Firewall <br>
445 - SMB <br>
502 - Modbus <br>
512 - Rexec <br>
513 - Rlogin <br>
514 - Rsh <br>
515 - Line Printer Daemon (LPD) <br>
548 - Apple Filing Protocol (AFP) <br>
554 - RTSP (Real Time Streaming Protocol) <br>
631 - Cups <br>
749 - Kerberos (v5 administration and kpasswwd service) <br>
761 - Kerberos (v4 password changing service) <br>
873 - rsync <br>
1025 - NFS or IIS (Indicates Windows operating system) <br>
1433 - MsSQL <br>
1521 - Oracle database <br>
2100 - Oracle XML DB FTP <br>
3306 - MySQL database <br>
3339 - Oracle web interface <br>
3389 - Remote Desktop Protocol <br>
5037, 5555 - ADB (Android Debug Bridge) <br>
5800, 5900 - VNC <br>
5985, 5986 - Winrm (Windows Remote Management) <br>
6667 - IRC TCP <br>
9389 - ADAC (Active Directory Administrative Center)<br>
<br>

### UDP Ports

---
67 - DHCP <br>
69 - TFTP <br>
464 - Kerberos (v5 password changing service) <br>
500 - IPsec/IKE VPN <br>
4444 - Kerberos (v5 ticket conversion service) <br>
5353 - mDNS<br>
<br>

### TCP/UDP Ports

---
42 - Windows Internet Name Service (WINS) <br>
53 - DNS <br>
88 - Kerberos (v5 ticket service) <br>
111 - Rpcbind <br>
123 - NTP <br>
135 - MSRPC <br>
137 - Netbios Name Service <br>
139 - Netbios Session Service <br>
161, 162, 10161, 10162 - SNMP <br>
194, 529 - IRC <br>
389, 636 - Ldap <br>
750 - Kerberos (v4 ticket service) <br>
751 - Kerberos (v4 admin service) <br>
1030, 1032, 1033, 1038 - (Good indicator of Windows domain) <br>
1748, 1754, 1808, 1809 - Oracle intelligent agent <br>
2049 - NFS <br>
3268,3269 - globalcatLdap <br>
4445 - Upnotifyp <br>
4555 - RSIP <br>
5357 - WSDAPI <br>
5722 - DFSR (Distributed File System Replication) <br>
47001 - Windows Remote Management Service <br>
<br>

## Services to consider adding

---
623 tcp/udp - Intelligent Platform Management Interface (IPMI) <br>
1026 udp - Rusersd <br>
1080 - Socks <br>
1050,1098,1099 tcp - Java RMI <br>
1723 tcp - Point-to-Point Tunneling Protocol (PPTP) <br>
1883 tcp - Mosquito <br>
2301,2381 - Compaq/HP Insight Manager <br>
2375,2376 - Docker <br>
3128 tcp - Squid <br>
3260 tcp - ISCSI <br>
3299 tcp - SAPRouter <br>
3632 tcp - distcc <br>
3690 tcp - Subversion (svn server) <br>
3702 udp - WS-Discovery <br>
4369 tcp - Erlang Port Mapper Daemon (epmd) <br>
4786 tcp - Cisco Smart Install <br>
5000 tcp - Docker Registry <br>
5432,5433 tcp - Postgresql <br>
5439 - Redshift <br>
5601 - Kibana <br>
5671,5672 - RabbitMQ (AMQP) <br>
5984,6984 - CouchDB <br>
5985,5986 tcp - OMI <br>
6000 tcp - X11 <br>
6379 tcp - Redis <br>
8009 tcp - Apache JServ (AJP) <br>
8086 tcp - InfluxDB <br>
8089 tcp - Splunkd <br>
8333,18333,38333,18444 tcp - Bitcoin <br>
9001 tcp - HyperSQL Database (HSQLDB) <br>
9042,9160 tcp - Apache Cassandra <br>
9100 tcp - Raw printing (JetDirect, AppSocket, PDL-Datastream) <br>
9200 tcp - Elasticsearch <br>
10000 tcp - Network Data Management Protocol (NDMP) <br>
11210 tcp - Memcache <br>
15672 - RabbitMQ Management <br>
24007,24008,24009,49152 tcp - GlusterFS <br>
27017,27018 - MongoDB <br>
44134 tcp - Tiller (Helm Kubernetes packager manager) <br>
44818 tcp/udp - EthernetIP <br>
47808 udp - BACNet <br>
50030,50060,50070,50075,50090 - Hadoop <br>
<br>


## Function Layout
-- pentest_automater.py --
> nmap_handler &nbsp;-&nbsp; Command execution function for nmap initial probing scans.

> scan_process &nbsp;-&nbsp; Begins by setting up process logging facilities, file paths, and
> directories. If there are no specified ports in config file, nmap scans will be skipped assuming
> the ports have already been enumerated. Otherwise, an initial nmap scan is run, followed by
> corresponding tool chains configured based on regex matching of open ports, finishing with a full
> nmap scan checking all ports.

> ScanClass &nbsp;-&nbsp; The scan process service handler class, which maps the ports of interest
> to their associated service handler function to later be referenced for execution.

> main &nbsp;-&nbsp; Loads the config file, depending on config file settings, either runs ping scan
> to identify hosts or already has target host in config file, and launches the scan process on 
> target hosts based on the available number of cpu's.

> log_handler &nbsp;-&nbsp; Logging thread that handles multiprocessing logging through the dedicated queue.

-- utils.py --
> cmd_parser &nbsp;-&nbsp; Take input command parsed from yaml file, and parses in any delimiters 
> in the command with passed in variable length parameters.

> ConfigClass &nbsp;-&nbsp; Class to store yaml file configurations that are referenced throughout operations.

> config_input &nbsp;-&nbsp; Prompts user for yaml configuration to use for scan automation.

> error_query &nbsp;-&nbsp; Looks up the errno message to get description.

> file_handler &nbsp;-&nbsp; Read/Write file operation handler for text and yaml file formats.

> logger_config &nbsp;-&nbsp; Retrieves the logging configuration in dict form.

> markdown_formatter &nbsp;-&nbsp; Crawls recursively through output dir and converts text output file into markdown copy.

> print_err &nbsp;-&nbsp; Displays the error message through stderr (standard error) with multiprocessing locking support.

> RegexHandler &nbsp;-&nbsp; Class object to store compiled regex patterns.<br>
> &emsp; scan_parse &nbsp;-&nbsp;Takes the nmap scan output and performs regex matches to identify open ports.
> The result is returned in a dictionary with mapped comma separated ports. 

> service_handler &nbsp;-&nbsp; Takes passed in service information and executes commands parsed from yaml config file.

> system_cmd &nbsp;-&nbsp; Executes system shell command and returns the output. If improper data type is in command syntax list
> or error occurs during command execution, the error is displayed via stderr and logged, and False is returned to indicated failed operation.

-- tcp_handlers.py, udp_handlers.py, tcp_udp_handlers.py --
> There is around 4 dozen services handled by Pentesters Toolchain, each service has its own handler
> function to parse and execute corresponding commands from the yaml config class. The functions are
> laid out in the same manner as the service layout in this section [Supported Service Ports](#supported-service-ports)

## Exit Codes
-- pentest_automater.py --
> 0 - Successful execution (__main__)
> 1 - Unexpected exception occurred (__main__)
> 2 - If error occurs acquiring targets from YAML config file or initial ping scan fails or error rendering banner (main)
> 3 - If error occurs setting up CIDR subnet ping executor (ping_executor)
> 4 - If initial nmap scan fails or ports in regex scan parse do not properly match assigned keys (scan_process)
> 5 - If service function handler fails due to non-existing key or port fails to convert to int (scan_process)

-- utils.py --
> 6 - If file operation was attempted on non-existing file (error_query)
> 7 - If file operation was attempted on file that user does not have access to (error_query)
> 8 - If IO error occurred during file operation (error_query)
> 9 - If unexpected error occurred during file operation (error_query)
> 10 - If write file operation is attempted with no data to write to the file (file_handler) 
> 11 - If attempting to write data to YAML config file (file_handler)
> 12 - If fatal error occurs attempting to execute command (system_cmd)