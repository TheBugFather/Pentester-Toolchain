""" Built-in modules """
import logging
import re
import sys
import threading
import time
from concurrent.futures import BrokenExecutor, ThreadPoolExecutor
from multiprocessing import cpu_count, Process
from queue import Queue
# Custom Modules #
from Modules.utils import CompiledRegex, ConfigClass, file_handler, ProgramPaths, print_err


# Global variables #
MIN_CORES = 2
THREAD_LOCAL = threading.local()


def scan_process(target_ip: str, regex_obj: object, paths_obj: object, configs_obj: object):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param paths_obj:  Tuple contain pathlib paths to program directories.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :return:  Nothing
    """
    # TCP Ports
    # ----------
    # 20,21 - FTP
    # 22 - SSH
    # 23 - Telnet
    # 25,465,587,2525 - SMTP
    # 79 - Finger
    # HTTP/HTTPS 80,443,8080,8443
    # 110,995 - Pop3/Pop3 over TLS
    # 119,433 - NNTP/NNTPS (Network News Transport Protocol)
    # 143,993 - IMAP/IMAP over TLS
    # 199 - SNMP Smux
    # 445 - SMB
    # 554 - RTSP
    # 631 - Cups
    # 749 - Kerberos (v5 administration and kpasswwd service)
    # 761 - Kerberos (v4 password changing service)
    # 873 - rsync
    # 1025 - NFS or IIS (Indicates Windows operating system)
    # 1433 - MsSQL
    # 1521 - Oracle database
    # 2100 - Oracle XML DB FTP
    # 3306 - MySQL database
    # 3339 - Oracle web interface
    # 3389 - Remote Desktop Protocol
    # 5037,5555 - Android Debug Bridge
    # 5800,5900 - VNC
    # 5985,5986 - Windows Remote Management
    # 9389 - Active Directory Administrative Center

    # UDP Ports
    # ----------
    # 67 - DHCP
    # 69 - TFTP
    # 464 - Kerberos (v5 password changing service)
    # 4444 - Kerberos (v5 ticket conversion service)
    # 5353 - mDNS

    # TCP/UDP Ports
    # --------------
    # 42 - Windows Internet Name Service (WINS)
    # 53 - DNS
    # 88 - Kerberos (v5 ticket service)
    # 111 - Rpcbind
    # 123 - NTP
    # 135 - MSRPC
    # 137 - Netbios Name Service
    # 139 - Netbios Session Service
    # 161,162,10161,10162 - SNMP
    # 389,636 - Ldap
    # 750 - Kerberos (v4 ticket service)
    # 751 - Kerberos (v4 admin service)
    # 1030,1032,1033,1038 - (Good indicator of Windows domain)
    # 1748,1754,1808,1809 - Oracle intelligent agent
    # 2049 - NFS
    # 3268,3269 - globalcatLdap
    # 4445 - Upnotifyp
    # 4555 - RSIP
    # 5357 - WSDAPI
    # 5722 - DFSR
    # 47001 - Windows Remote Management Service

    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        filename = paths_obj.cwd / 'nmapSampleOutputs' / 'blueprint_nmapOut.txt'
        # Read the nmap scan output #
        nmap_output = file_handler(filename, 'r')

        ''' TCP port regex matches '''
        ftp_match = re.search(regex_obj.re_ftp, nmap_output)
        ssh_match = re.search(regex_obj.re_ssh, nmap_output)
        telnet_match = re.search(regex_obj.re_telnet, nmap_output)
        smtp_match = re.search(regex_obj.re_smtp, nmap_output)
        finger_match = re.search(regex_obj.re_finger, nmap_output)
        web_match = re.search(regex_obj.re_web, nmap_output)
        pop3_match = re.search(regex_obj.re_pop3, nmap_output)
        nntp_match = re.search(regex_obj.re_nntp, nmap_output)
        imap_match = re.search(regex_obj.re_imap, nmap_output)
        smux_match = re.search(regex_obj.re_smux, nmap_output)
        smb_match = re.search(regex_obj.re_smb, nmap_output)
        rtsp_match = re.search(regex_obj.re_rtsp, nmap_output)
        cups_match = re.search(regex_obj.re_cups, nmap_output)
        kerbv5_passwd_tcp_match = re.search(regex_obj.re_kerbv5_passwd_tcp, nmap_output)
        kerbv4_passwd_tcp_match = re.search(regex_obj.re_kerbv4_passwd_tcp, nmap_output)
        rsync_match = re.search(regex_obj.re_rsync, nmap_output)
        iss_match = re.search(regex_obj.re_iss, nmap_output)
        mssql_match = re.search(regex_obj.re_mssql, nmap_output)
        oracle_db_match = re.search(regex_obj.re_oracle_db, nmap_output)
        oracle_xmldb_match = re.search(regex_obj.re_oracle_xmldb, nmap_output)
        sql_match = re.search(regex_obj.re_sql, nmap_output)
        oracle_web_match = re.search(regex_obj.re_oracle_web, nmap_output)
        rdp_match = re.search(regex_obj.re_rdp, nmap_output)
        adb_match = re.search(regex_obj.re_adb, nmap_output)
        vnc_match = re.search(regex_obj.re_vnc, nmap_output)
        winrm_match = re.search(regex_obj.re_winrm, nmap_output)
        ad_admin_match = re.search(regex_obj.re_ad_admin, nmap_output)

        ''' UDP port regex matches '''
        dhcp_match = re.search(regex_obj.re_dhcp, nmap_output)
        tftp_match = re.search(regex_obj.re_tftp, nmap_output)
        kerbv5_passwd_udp_match = re.search(regex_obj.re_kerbv5_passwd_udp, nmap_output)
        kerbv5_ticket_udp_match = re.search(regex_obj.re_kerbv5_ticket_conv_udp, nmap_output)
        mdns_match = re.search(regex_obj.re_mdns, nmap_output)

        ''' TCP/UDP port regex matches '''
        wins_match = re.search(regex_obj.re_wins, nmap_output)
        dns_match = re.search(regex_obj.re_dns, nmap_output)
        kerbv5_ticket_match = re.search(regex_obj.re_kerbv5_ticket, nmap_output)
        rpc_match = re.search(regex_obj.re_rpc, nmap_output)
        ntp_match = re.search(regex_obj.re_ntp, nmap_output)
        msrpc_match = re.search(regex_obj.re_msrpc, nmap_output)
        netbios_name_match = re.search(regex_obj.re_netbios_name, nmap_output)
        netbios_sesh_match = re.search(regex_obj.re_netbios_sesh, nmap_output)
        snmp_match = re.search(regex_obj.re_snmp, nmap_output)
        ldap_match = re.search(regex_obj.re_ldap, nmap_output)
        kerbv4_ticket_match = re.search(regex_obj.re_kerbv4_ticket, nmap_output)
        kerbv4_admin_match = re.search(regex_obj.re_kerbv4_admin, nmap_output)
        windomain_indicator_match = re.search(regex_obj.re_windomain_indicator, nmap_output)
        oracle_agent_match = re.search(regex_obj.re_oracle_agent, nmap_output)
        nfs_match = re.search(regex_obj.re_nfs, nmap_output)
        globalcat_ldap_match = re.search(regex_obj.re_globalcat_ldap, nmap_output)
        upnotifyp_match = re.search(regex_obj.re_upnotifyp, nmap_output)
        rsip_match = re.search(regex_obj.re_sip, nmap_output)
        wsdapi_match = re.search(regex_obj.re_wsdapi, nmap_output)
        dfsr_match = re.search(regex_obj.re_dfsr, nmap_output)
        wrms_match = re.search(regex_obj.re_wrms, nmap_output)

        # If there were ftp ports open #
        if ftp_match:
            print('Open ftp port regex successfully matched!\n')

        # If the sql port is open #
        if sql_match:
            print('Open SQL port regex successfully matched\n')

        # If there a http(s) port is open #
        if web_match:
            print('Open web ports regex successfully matched!\n')

        # If telnet port is open #
        if telnet_match:
            print('Open telnet port regex successfully matched!\n')

        # If ssh port is open #
        if ssh_match:
            print('Open ssh port regex successfully matched!\n')

        # If an SMTP port is open #
        if smtp_match:
            print('Open smtp port regex successfully matched!\n')

        # If finger port is open #
        if finger_match:
            print('Open finger port regex successfully matched!\n')

    # If ports already were identified on target #
    else:
        for port in configs_obj.ports:
            # If ftp port in yaml #
            if port in (20, 21):
                pass


def ping_handler(addr_queue: Queue):
    # TODO: Parse input into ping able range and execute through ThreadPoolExecutor

    return addr_queue


def main():
    """
    Loads the config file, runs ping scan to get hosts if subnet scan specified, and launches the
    scan process on target hosts based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_queue = Queue()
    joined_procs = []

    # Compile program regex and return as object #
    re_obj = CompiledRegex()

    # Load the YAML configuration file #
    config_data = file_handler(path_obj.yaml_file, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue #
        [hosts.put(host) for host in config_obj.hosts]
    # If CIDR network range is specified #
    elif config_obj.cidr:
        # Run ping scan of target hosts #
        hosts = ping_handler(hosts)
    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    while True:
        # Iterate through join list #
        for proc in joined_procs:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from join list #
                joined_procs.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not joined_procs:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, path_obj, config_obj))
            # Start process and put in process queue #
            process.start()
            proc_queue.put(process)
            num_cpu -= 1

        # While process queue has processes #
        while not proc_queue.empty():
            # Get process from queue and join it #
            process = proc_queue.get()
            process.join()
            # Add process to join list after join #
            joined_procs.append(process)


if __name__ == '__main__':
    RET = 0

    # Initialize and set program paths #
    path_obj = ProgramPaths()

    # Set the log file name #
    logging.basicConfig(filename=path_obj.log_file, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

    # Iterate created path objects #
    for folder in (path_obj.cwd, path_obj.out_dir, path_obj.exploit_dir, path_obj.loot_dir,
                   path_obj.report_dir, path_obj.pic_dir, path_obj.scan_dir):
        # If the scan output directory does not exist #
        if not folder.exists():
            # Create the scan directory #
            folder.mkdir(parents=True)

    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        logging.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    print(f'\n[!] Execution time: {exec_time}')
    logging.info('Execution time: %s\n\n', exec_time)

    sys.exit(RET)
