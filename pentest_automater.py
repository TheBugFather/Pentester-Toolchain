""" Built-in modules """
import logging
import re
import sys
import threading
import time
from concurrent.futures import BrokenExecutor, ThreadPoolExecutor
from multiprocessing import cpu_count, Process
from queue import Queue
# Custom Modules #
from Modules.tcp_handlers import ftp_handler, ssh_handler, telnet_handler, smtp_handler, \
                                 finger_handler, web_handler
from Modules.utils import CompiledRegex, ConfigClass, file_handler, ProgramPaths, print_err


# Global variables #
THREAD_LOCAL = threading.local()


def scan_process(target_ip: str, regex_obj: object, paths_obj: object, configs_obj: object):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param paths_obj:  Tuple contain pathlib paths to program directories.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :return:  Nothing
    """
    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        # TODO add in nmap scan
        filename = paths_obj.cwd / 'nmapSampleOutputs' / 'blueprint_nmapOut.txt'
        # Read the nmap scan output #
        nmap_output = file_handler(filename, 'r')

        # TCP port regex matches #
        ftp_match = re.search(regex_obj.re_ftp, nmap_output)
        ssh_match = re.search(regex_obj.re_ssh, nmap_output)
        telnet_match = re.search(regex_obj.re_telnet, nmap_output)
        smtp_match = re.search(regex_obj.re_smtp, nmap_output)
        finger_match = re.search(regex_obj.re_finger, nmap_output)
        web_match = re.search(regex_obj.re_web, nmap_output)
        pop3_match = re.search(regex_obj.re_pop3, nmap_output)
        nntp_match = re.search(regex_obj.re_nntp, nmap_output)
        imap_match = re.search(regex_obj.re_imap, nmap_output)
        smux_match = re.search(regex_obj.re_smux, nmap_output)
        smb_match = re.search(regex_obj.re_smb, nmap_output)
        rtsp_match = re.search(regex_obj.re_rtsp, nmap_output)
        cups_match = re.search(regex_obj.re_cups, nmap_output)
        kerbv5_admin_tcp_match = re.search(regex_obj.re_kerbv5_admin_tcp, nmap_output)
        kerbv4_passwd_tcp_match = re.search(regex_obj.re_kerbv4_passwd_tcp, nmap_output)
        rsync_match = re.search(regex_obj.re_rsync, nmap_output)
        iss_match = re.search(regex_obj.re_iss, nmap_output)
        mssql_match = re.search(regex_obj.re_mssql, nmap_output)
        oracle_db_match = re.search(regex_obj.re_oracle_db, nmap_output)
        oracle_xmldb_match = re.search(regex_obj.re_oracle_xmldb, nmap_output)
        sql_match = re.search(regex_obj.re_sql, nmap_output)
        oracle_web_match = re.search(regex_obj.re_oracle_web, nmap_output)
        rdp_match = re.search(regex_obj.re_rdp, nmap_output)
        adb_match = re.search(regex_obj.re_adb, nmap_output)
        vnc_match = re.search(regex_obj.re_vnc, nmap_output)
        winrm_match = re.search(regex_obj.re_winrm, nmap_output)
        ad_admin_match = re.search(regex_obj.re_ad_admin, nmap_output)

        # UDP port regex matches #
        dhcp_match = re.search(regex_obj.re_dhcp, nmap_output)
        tftp_match = re.search(regex_obj.re_tftp, nmap_output)
        kerbv5_passwd_udp_match = re.search(regex_obj.re_kerbv5_passwd_udp, nmap_output)
        kerbv5_ticket_udp_match = re.search(regex_obj.re_kerbv5_ticket_conv_udp, nmap_output)
        mdns_match = re.search(regex_obj.re_mdns, nmap_output)

        # TCP/UDP port regex matches #
        wins_match = re.search(regex_obj.re_wins, nmap_output)
        dns_match = re.search(regex_obj.re_dns, nmap_output)
        kerbv5_ticket_match = re.search(regex_obj.re_kerbv5_ticket, nmap_output)
        rpc_match = re.search(regex_obj.re_rpc, nmap_output)
        ntp_match = re.search(regex_obj.re_ntp, nmap_output)
        msrpc_match = re.search(regex_obj.re_msrpc, nmap_output)
        netbios_name_match = re.search(regex_obj.re_netbios_name, nmap_output)
        netbios_sesh_match = re.search(regex_obj.re_netbios_sesh, nmap_output)
        snmp_match = re.search(regex_obj.re_snmp, nmap_output)
        ldap_match = re.search(regex_obj.re_ldap, nmap_output)
        kerbv4_ticket_match = re.search(regex_obj.re_kerbv4_ticket, nmap_output)
        kerbv4_admin_match = re.search(regex_obj.re_kerbv4_admin, nmap_output)
        windomain_indicator_match = re.search(regex_obj.re_windomain_indicator, nmap_output)
        oracle_agent_match = re.search(regex_obj.re_oracle_agent, nmap_output)
        nfs_match = re.search(regex_obj.re_nfs, nmap_output)
        globalcat_ldap_match = re.search(regex_obj.re_globalcat_ldap, nmap_output)
        upnotifyp_match = re.search(regex_obj.re_upnotifyp, nmap_output)
        rsip_match = re.search(regex_obj.re_sip, nmap_output)
        wsdapi_match = re.search(regex_obj.re_wsdapi, nmap_output)
        dfsr_match = re.search(regex_obj.re_dfsr, nmap_output)
        wrms_match = re.search(regex_obj.re_wrms, nmap_output)

        ''' TCP port matches '''
        # If a ftp port is open #
        if ftp_match:
            # If port 20 in match result #
            if '20' in ftp_match.group(0):
                port = 20
            # If port 21 in match result #
            else:
                port = 21

            # Execute yaml commands for ftp #
            ftp_handler(port, configs_obj)

        # If ssh port is open #
        if ssh_match:
            # Execute yaml commands for ssh #
            ssh_handler(22, configs_obj)

        # If telnet port is open #
        if telnet_match:
            # Execute yaml commands for telnet #
            telnet_handler(23, configs_obj)

        # If a SMTP port is open #
        if smtp_match:
            # If port 25 in match result #
            if '25' in smtp_match.group(0):
                port = 25
            # If port 465 in match result #
            elif '465' in smtp_match.group(0):
                port = 465
            # If port 587 in match result #
            elif '587' in smtp_match.group(0):
                port = 587
            # If port 2525 in match result #
            else:
                port = 2525

            # Execute yaml commands for smtp #
            smtp_handler(port, configs_obj)

        # If finger port is open #
        if finger_match:
            # Execute yaml commands for finger #
            finger_handler(79, configs_obj)

        # If a http(s) port is open #
        if web_match:
            # If port 80 in match result #
            if '80' in web_match.group(0):
                port = 80
            # If port 443 in match result #
            elif '443' in web_match.group(0):
                port = 443
            # If port 8080 in match result #
            elif '8080' in web_match.group(0):
                port = 8080
            # If port 8443 in match result #
            else:
                port = 8443

            # Execute yaml commands for web #
            web_handler(port, configs_obj)

        # If a pop3 port is open #
        if pop3_match:
            # TODO figure out what port matched

            # Iterate through pop3 commands from yaml file #
            for command in configs_obj.pop3:
                pass

        # If a nntp port is open #
        if nntp_match:
            # TODO figure out what port matched

            # Iterate through nntp commands from yaml file #
            for command in configs_obj.nntp:
                pass

        # If a imap port is open #
        if imap_match:
            # TODO figure out what port matched

            # Iterate through imap commands from yaml file #
            for command in configs_obj.imap:
                pass

        # If smux port is open #
        if smux_match:
            # Iterate through smux commands from yaml file #
            for commmand in configs_obj.smux:
                pass

        # If smb port is open #
        if smb_match:
            # Iterate through smb commands from yaml file #
            for command in configs_obj.smb:
                pass

        # If rtsp port is open #
        if rtsp_match:
            # Iterate through rtsp commands from yaml file #
            for command in configs_obj.rtsp:
                pass

        # If cups port is open #
        if cups_match:
            # Iterate through cups commands from yaml file #
            for command in configs_obj.cups:
                pass

        # If kerberos v5 admin tcp port is open #
        if kerbv5_admin_tcp_match:
            # Iterate through kerberos v5 admin tcp commands from yaml file #
            for command in configs_obj.kerberos_v5_admin_tcp:
                pass

        # If kerberos v4 passwd tcp port is open #
        if kerbv4_passwd_tcp_match:
            # Iterate through kerberos v4 passwd tcp commands from yaml file #
            for command in configs_obj.kerberos_v4_passwd_tcp:
                pass

        # If rsync port is open #
        if rsync_match:
            # Iterate through rsync commands from yaml file #
            for command in configs_obj.rsync:
                pass

        # If iis port is open #
        if iss_match:
            # Iterate through iss commands from yaml file #
            for command in configs_obj.iss:
                pass

        # If mssql port is open #
        if mssql_match:
            # Iterate through mssql commands from yaml file #
            for command in configs_obj.mssql:
                pass

        # If oracle db port is open #
        if oracle_db_match:
            # Iterate through oracle db commands from yaml file #
            for command in configs_obj.oracle_db:
                pass

        # If oracle xml db port is open #
        if oracle_xmldb_match:
            # Iterate through oracle xml db commands from yaml file #
            for command in configs_obj.oracle_xml_db:
                pass

        # If mysql port is open #
        if sql_match:
            # Iterate through sql commands from yaml file #
            for command in configs_obj.sql:
                pass

        # If oracle web port is open #
        if oracle_web_match:
            # Iterate through oracle web commands from yaml file #
            for command in configs_obj.oracle_web:
                pass

        # If rdp port is open #
        if rdp_match:
            # Iterate through rdp commands from yaml file #
            for command in configs_obj.rdp:
                pass

        # If a adb port is open #
        if adb_match:
            # TODO figure out what port matched

            # Iterate through adb commands from yaml file #
            for command in configs_obj.adb:
                pass

        # If a vnc port is open #
        if vnc_match:
            # TODO figure out what port matched

            # Iterate through vnc commands from yaml file #
            for command in configs_obj.vnc:
                pass

        # If a winrm port is open #
        if winrm_match:
            # TODO figure out what port matched

            # Iterate through winrm commands from yaml file #
            for command in configs_obj.winrm:
                pass

        # If active directory admin center port is open #
        if ad_admin_match:
            # Iterate through ad admin center commands from yaml file #
            for command in configs_obj.adac:
                pass

        ''' UDP port matches '''
        # If dhcp port is open #
        if dhcp_match:
            # Iterate through dhcp commands from yaml file #
            for command in configs_obj.dhcp:
                pass

        # If tftp port is open #
        if tftp_match:
            # Iterate through tftp commands from yaml file #
            for command in configs_obj.tftp:
                pass

        # If kerberos v5 passwd udp port is open #
        if kerbv5_passwd_udp_match:
            # Iterate through kerberos v5 passwd udp commands from yaml file #
            for command in configs_obj.kerberos_v5_passwd_udp:
                pass

        # If kerberos v5 ticket udp port is open #
        if kerbv5_ticket_udp_match:
            # Iterate through kerberos v5 ticket udp commands from yaml file #
            for command in configs_obj.kerberos_v5_ticket_udp:
                pass

        # If multicast dns port is open #
        if mdns_match:
            # Iterate through mdns commands from yaml file #
            for command in configs_obj.mdns:
                pass

        ''' TCP/UDP port matches '''
        # If wins port is open #
        if wins_match:
            # Iterate through wins commands from yaml file #
            for command in configs_obj.wins:
                pass

        # If dns port is open #
        if dns_match:
            # TODO potentially find out whether tcp or udp

            # Iterate through dns commands from yaml file #
            for command in configs_obj.dns:
                pass

        # If kerberos v5 ticket port is open #
        if kerbv5_ticket_match:
            # Iterate through kerberos v5 ticket commands from yaml file #
            for command in configs_obj.kerberos_v5_ticket:
                pass

        # If rpc port is open #
        if rpc_match:
            # Iterate through rpc commands from yaml file #
            for command in configs_obj.rpc:
                pass

        # If ntp port is open #
        if ntp_match:
            # Iterate through ntp commands from yaml file #
            for command in configs_obj.ntp:
                pass

        # If msrpc port is open #
        if msrpc_match:
            # Iterate through msrpc commands from yaml file #
            for command in configs_obj.msrpc:
                pass

        # If netbios name port is open #
        if netbios_name_match:
            # Iterate through netbios name commands from yaml file #
            for command in configs_obj.netbios_name:
                pass

        # If netbios session port is open #
        if netbios_sesh_match:
            # Iterate through netbios session commands from yaml file #
            for command in configs_obj.netbios_sesh:
                pass

        # If a snmp port is open #
        if snmp_match:
            # TODO find out what port matched

            # Iterate through snmp commands from yaml file #
            for command in configs_obj.snmp:
                pass

        # If a ldap port is open #
        if ldap_match:
            # TODO find out what port matched

            # Iterate through ldap commands from yaml file #
            for command in configs_obj.ldap:
                pass

        # If kerberos v4 ticket port is open #
        if kerbv4_ticket_match:
            # Iterate through kerberos v5 ticket commands from yaml file #
            for command in configs_obj.kerberos_v4_ticket:
                pass

        # If kerberos v4 admin port is open #
        if kerbv4_admin_match:
            # Iterate through kerberos v4 admin commands from yaml file #
            for command in configs_obj.kerberos_v4_admin:
                pass

        # If a port indicating windows domain is open #
        if windomain_indicator_match:
            # TODO find out what port matched

            # Iterate through windows domain commands from yaml file #
            for command in configs_obj.windomain_indicator:
                pass

        # If a oracle intelligent port is open
        if oracle_agent_match:
            # TODO find out what port matched

            # Iterate through oracle agent commands from yaml file #
            for command in configs_obj.oracle_agent:
                pass

        # If nfs port is open #
        if nfs_match:
            # Iterate through nfs commands from yaml file #
            for command in configs_obj.nfs:
                pass

        # If a globalcat ldap port is open #
        if globalcat_ldap_match:
            # TODO find out what port matched

            # Iterate through globalcat ldap commands from yaml file #
            for command in configs_obj.globalcat_ldap:
                pass

        # If upnotifyp port is open #
        if upnotifyp_match:
            # Iterate through upnotifyp commands from yaml file #
            for command in configs_obj.upnotifyp:
                pass

        # If rsip port is open #
        if rsip_match:
            # Iterate through rsip commands from yaml file #
            for command in configs_obj.rsip:
                pass

        # If wsdapi port is open #
        if wsdapi_match:
            # Iterate through wsdapi commands from yaml file #
            for command in configs_obj.wsdapi:
                pass

        # If dfsr port is open #
        if dfsr_match:
            # Iterate through dfsr commands from yaml file #
            for command in configs_obj.dfsr:
                pass

        # If wrms port is open #
        if wrms_match:
            # Iterate through wrms commands from yaml file #
            for command in configs_obj.wrms:
                pass

    # If ports already were identified on target #
    else:
        # Iterate through port list from yaml config #
        for port in configs_obj.ports:
            ''' TCP based ports '''
            # If a ftp port in yaml #
            if port in (20, 21):
                # Iterate through ftp commands from yaml file #
                for commnd in configs_obj.ftp:
                    pass

            # If ssh port in yaml #
            if port == 22:
                # Iterate through ssh commands from yaml file #
                for command in configs_obj.ssh:
                    pass

            # If telnet port in yaml #
            if port == 23:
                # Iterate through telnet commands from yaml file #
                for command in configs_obj.telnet:
                    pass

            # If a smtp port in yaml #
            if port in (25, 465, 587, 2525):
                # Iterate through smtp commands from yaml file #
                for command in configs_obj.smtp:
                    pass

            # If finger port in yaml #
            if port == 79:
                # Iterate through finger commands from yaml file #
                for command in configs_obj.finger:
                    pass

            # If a web port in yaml #
            if port in (80, 443, 8080, 8443):
                # Iterate through finger commands from yaml file #
                for command in configs_obj.web:
                    pass

            # If a pop3 port in yaml #
            if port in (110, 995):
                # Iterate through finger commands from yaml file #
                for command in configs_obj.pop3:
                    pass

            # If a nntp port in yaml #
            if port in (119, 443):
                # Iterate through nntp commands from yaml file #
                for command in configs_obj.nntp:
                    pass

            # If a imap port in yaml #
            if port in (143, 993):
                # Iterate through imap commands from yaml file #
                for command in configs_obj.imap:
                    pass

            # If smux port in yaml #
            if port == 199:
                # Iterate through smux commands from yaml file #
                for command in configs_obj.smux:
                    pass

            # If smb port in yaml #
            if port == 445:
                # Iterate through smb commands from yaml file #
                for command in configs_obj.smb:
                    pass

            # If rtsp port in yaml #
            if port == 554:
                # Iterate through rtsp commands from yaml file #
                for command in configs_obj.rtsp:
                    pass

            # If cups port in yaml #
            if port == 631:
                # Iterate through cups commands from yaml file #
                for command in configs_obj.cups:
                    pass

            # If kerberos v5 admin tcp port from yaml file #
            if port == 749:
                # Iterate through kerberos v5 admin tcp commands from yaml file #
                for command in configs_obj.kerberos_v5_admin:
                    pass

            # If kerberos v4 passwd tcp port from yaml file #
            if port == 761:
                pass



def ping_handler(addr_queue: Queue):
    # TODO: Parse input into ping able range and execute through ThreadPoolExecutor

    return addr_queue


def main():
    """
    Loads the config file, runs ping scan to get hosts if subnet scan specified, and launches the
    scan process on target hosts based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_queue = Queue()
    joined_procs = []

    # Compile program regex and return as object #
    re_obj = CompiledRegex()

    # Load the YAML configuration file #
    config_data = file_handler(path_obj.yaml_file, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue #
        [hosts.put(host) for host in config_obj.hosts]
    # If CIDR network range is specified #
    elif config_obj.cidr:
        # Run ping scan of target hosts #
        hosts = ping_handler(hosts)
    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    while True:
        # Iterate through join list #
        for proc in joined_procs:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from join list #
                joined_procs.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not joined_procs:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, path_obj, config_obj))
            # Start process and put in process queue #
            process.start()
            proc_queue.put(process)
            num_cpu -= 1

        # While process queue has processes #
        while not proc_queue.empty():
            # Get process from queue and join it #
            process = proc_queue.get()
            process.join()
            # Add process to join list after join #
            joined_procs.append(process)


if __name__ == '__main__':
    RET = 0

    # Initialize and set program paths #
    path_obj = ProgramPaths()

    # Set the log file name #
    logging.basicConfig(filename=path_obj.log_file, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

    # Iterate created path objects #
    for folder in (path_obj.cwd, path_obj.out_dir, path_obj.exploit_dir, path_obj.loot_dir,
                   path_obj.report_dir, path_obj.pic_dir, path_obj.scan_dir):
        # If the scan output directory does not exist #
        if not folder.exists():
            # Create the scan directory #
            folder.mkdir(parents=True)

    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        logging.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    print(f'\n[!] Execution time: {exec_time}')
    logging.info('Execution time: %s\n\n', exec_time)

    sys.exit(RET)
