""" Built-in modules """
import asyncio
import logging
import multiprocessing
import re
import sys
import time
from pathlib import Path
from queue import Queue
# Custom Modules #
from Modules.utils import file_handler, print_err


# The amount of cores to leave alone #
MIN_CORES = 2


def scan_process(target_ip, path_tuple):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :return:  Nothing
    """
    # TODO service ports to consider
    # 135 - Windows RPC
    # 139 - Windows Netbios-ssn

    # TODO Add more regex for various ports depending on intended functionality
    # Regex for matching http(s) web ports #
    re_web = re.compile(r'(?:80|443)/tcp {2,6}open')
    # Regex for matching sql port #
    re_sql = re.compile(r'3306/tcp {2,6}open')
    # Regex for matching ssh port #
    re_ssh = re.compile(r'22/tcp {2,6}open')
    # Regex for matching ftp port #
    re_ftp = re.compile(r'21/tcp {2,6}open')

    # TODO Add nmap functionality when reactive scanning system is set and reliable testing resources are in place

    filename = './nmapSampleOutputs/blueprint_nmapOut.txt'

    # Read the nmap scan output #
    nmap_output = file_handler(filename, 'r')

    # TODO run all compiled regex of potential ports of interest on nmap scan output
    # Check nmap scan output for open web ports #
    web_match = re.search(re_web, nmap_output)
    # Check nmap scan output for open SQL port #
    sql_match = re.search(re_sql, nmap_output)
    # Check nmap scan output for open ssh port #
    ssh_match = re.search(re_ssh, nmap_output)
    # Check nmap scan output for open ftp port #
    ftp_match = re.search(re_ftp, nmap_output)

    # If there were open http(s) ports #
    if web_match:
        print('Open web ports regex successfully matched!\n')

        # TODO Run general web application tools for any kind of server framework

        # TODO Figure out the specific framework of web server and run tools targets for that framework

        # TODO analyze results for potential CVE's and exploits

    # If the sql port is open #
    if sql_match:
        print('Open SQL port regex successfully matched\n')

        # TODO Run tools potential identify and exploit sql vulnerabilities

    # If ssh port is open #
    if ssh_match:
        print('Open ssh port regex successfully matched!\n')

        # TODO Run tools to potentially identify and exploit ssh vulnerabilities

    # If the ftp port is open #
    if ftp_match:
        print('Open ftp port regex successfully matched!\n')

        # TODO Run tools to potentially identify and exploit vulnerabilities


async def ping_scan(addr_queue):
    pass


def main():
    hosts = Queue()
    proc_queue = Queue()
    joined_procs = []

    # Get the async event loop #
    event_loop = asyncio.get_event_loop()
    # Run the async function until complete #
    hosts = event_loop.run_until_complete(ping_scan(hosts))

    while True:
        # Iterate through join list #
        for proc in joined_procs:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from join list #
                joined_procs.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not joined_procs:
            break

        # If there are cores available #
        if multiprocessing.cpu_count() > MIN_CORES:
            # While there are cores available #
            while multiprocessing.cpu_count() > MIN_CORES:
                # Create scan process with next available host #
                process = multiprocessing.Process(target=scan_process, args=(hosts.get(),
                                                                             program_dirs))
                process.start()
                proc_queue.put(process)

            # While process queue has processes #
            while not proc_queue.empty():
                # Get process from queue and join it #
                process = proc_queue.get()
                process.join()
                # Add process to join list after join #
                joined_procs.append(process)


if __name__ == '__main__':
    # Record the start time #
    start_time = time.perf_counter()

    RET = 0
    cwd = Path('.').absolute()
    out_dir = cwd / 'Output'
    exploit_dir = out_dir / 'Exploits'
    loot_dir = out_dir / 'Loot'
    report_dir = out_dir / 'Reports'
    pic_dir = report_dir / 'Screenshots'
    scan_dir = out_dir / 'ScanOutput'
    log_file = cwd / 'pentester_automater.log'
    # Pack paths in tuple grouping #
    program_dirs = (cwd, out_dir, exploit_dir, loot_dir, report_dir, pic_dir, scan_dir)

    # Set the log file name #
    logging.basicConfig(filename=log_file, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

    # Iterate created path objects #
    for folder in program_dirs:
        # If the scan output directory does not exist #
        if not folder.exists():
            # Create the scan directory #
            folder.mkdir()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        logging.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    end_time = time.perf_counter()
    exec_time = end_time - start_time

    print(f'\n[!] Execution time: {exec_time}')
    logging.info('Execution time: %s\n\n', exec_time)

    sys.exit(RET)
