""" Built-in modules """
import concurrent.futures
import logging
import re
import sys
import threading
import time
from concurrent.futures import BrokenExecutor, ThreadPoolExecutor
from multiprocessing import cpu_count, Process
from subprocess import check_output
from pathlib import Path
from queue import Queue
# External modules #
import ipaddress
# Custom Modules #
from Modules.tcp_handlers import ftp_handler, ssh_handler, telnet_handler, smtp_handler, \
                                 finger_handler, web_handler, pop3_handler, nntp_handler, \
                                 imap_handler, smux_handler, smb_handler, rtsp_handler, \
                                 cups_handler, kerbv5_admin_tcp, kerbv4_passwd_tcp, rsync_handler, \
                                 iis_handler, mssql_handler, oracle_db_handler, \
                                 oracle_xmldb_handler, sql_handler, oracle_web_handler, \
                                 rdp_handler, adb_handler, vnc_handler, winrm_handler, \
                                 ad_admin_handler
from Modules.tcp_udp_handlers import wins_handler, dns_handler, kerbv5_ticket_handler, \
                                     rpc_handler, ntp_handler, msrpc_handler, \
                                     netbios_name_handler, netbios_sesh_handler, snmp_handler, \
                                     ldap_handler, kerbv4_ticket_handler, kerbv4_admin_handler, \
                                     windomain_handler, oracle_agent_handler, nfs_handler, \
                                     globalcat_ldap_handler, upnotifyp_handler, rsip_handler, \
                                     wsdapi_handler, dfsr_handler, wrms_handler
from Modules.udp_handlers import dhcp_handler, tftp_handler, kerbv5_passwd_udp_handler, \
                                 kerbv5_ticket_udp_handler, mdns_handler
from Modules.utils import CompiledRegex, ConfigClass, config_input, file_handler, print_err


# Global variables #
THREAD_LOCAL = threading.local()

def scan_process(target_ip: str, regex_obj: object, base_path: Path, configs_obj: object,
                 logger_queue: Queue):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param base_path:  Path to the base directory for the project output.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :param logger_queue:  The queue used for handling inter-process logging.
    :return:  Nothing
    """
    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        # TODO add in nmap scan
        file_path = cwd / 'nmapSampleOutputs' / 'blueprint_nmapOut.txt'
        # Read the nmap scan output #
        nmap_output = file_handler(file_path, 'r')

        # TCP port regex matches #
        ftp_match = re.search(regex_obj.re_ftp, nmap_output)
        ssh_match = re.search(regex_obj.re_ssh, nmap_output)
        telnet_match = re.search(regex_obj.re_telnet, nmap_output)
        smtp_match = re.search(regex_obj.re_smtp, nmap_output)
        finger_match = re.search(regex_obj.re_finger, nmap_output)
        web_match = re.search(regex_obj.re_web, nmap_output)
        pop3_match = re.search(regex_obj.re_pop3, nmap_output)
        nntp_match = re.search(regex_obj.re_nntp, nmap_output)
        imap_match = re.search(regex_obj.re_imap, nmap_output)
        smux_match = re.search(regex_obj.re_smux, nmap_output)
        smb_match = re.search(regex_obj.re_smb, nmap_output)
        rtsp_match = re.search(regex_obj.re_rtsp, nmap_output)
        cups_match = re.search(regex_obj.re_cups, nmap_output)
        kerbv5_admin_tcp_match = re.search(regex_obj.re_kerbv5_admin_tcp, nmap_output)
        kerbv4_passwd_tcp_match = re.search(regex_obj.re_kerbv4_passwd_tcp, nmap_output)
        rsync_match = re.search(regex_obj.re_rsync, nmap_output)
        iss_match = re.search(regex_obj.re_iss, nmap_output)
        mssql_match = re.search(regex_obj.re_mssql, nmap_output)
        oracle_db_match = re.search(regex_obj.re_oracle_db, nmap_output)
        oracle_xmldb_match = re.search(regex_obj.re_oracle_xmldb, nmap_output)
        sql_match = re.search(regex_obj.re_sql, nmap_output)
        oracle_web_match = re.search(regex_obj.re_oracle_web, nmap_output)
        rdp_match = re.search(regex_obj.re_rdp, nmap_output)
        adb_match = re.search(regex_obj.re_adb, nmap_output)
        vnc_match = re.search(regex_obj.re_vnc, nmap_output)
        winrm_match = re.search(regex_obj.re_winrm, nmap_output)
        ad_admin_match = re.search(regex_obj.re_ad_admin, nmap_output)

        # UDP port regex matches #
        dhcp_match = re.search(regex_obj.re_dhcp, nmap_output)
        tftp_match = re.search(regex_obj.re_tftp, nmap_output)
        kerbv5_passwd_udp_match = re.search(regex_obj.re_kerbv5_passwd_udp, nmap_output)
        kerbv5_ticket_udp_match = re.search(regex_obj.re_kerbv5_ticket_conv_udp, nmap_output)
        mdns_match = re.search(regex_obj.re_mdns, nmap_output)

        # TCP/UDP port regex matches #
        wins_match = re.search(regex_obj.re_wins, nmap_output)
        dns_match = re.search(regex_obj.re_dns, nmap_output)
        kerbv5_ticket_match = re.search(regex_obj.re_kerbv5_ticket, nmap_output)
        rpc_match = re.search(regex_obj.re_rpc, nmap_output)
        ntp_match = re.search(regex_obj.re_ntp, nmap_output)
        msrpc_match = re.search(regex_obj.re_msrpc, nmap_output)
        netbios_name_match = re.search(regex_obj.re_netbios_name, nmap_output)
        netbios_sesh_match = re.search(regex_obj.re_netbios_sesh, nmap_output)
        snmp_match = re.search(regex_obj.re_snmp, nmap_output)
        ldap_match = re.search(regex_obj.re_ldap, nmap_output)
        kerbv4_ticket_match = re.search(regex_obj.re_kerbv4_ticket, nmap_output)
        kerbv4_admin_match = re.search(regex_obj.re_kerbv4_admin, nmap_output)
        windomain_indicator_match = re.search(regex_obj.re_windomain_indicator, nmap_output)
        oracle_agent_match = re.search(regex_obj.re_oracle_agent, nmap_output)
        nfs_match = re.search(regex_obj.re_nfs, nmap_output)
        globalcat_ldap_match = re.search(regex_obj.re_globalcat_ldap, nmap_output)
        upnotifyp_match = re.search(regex_obj.re_upnotifyp, nmap_output)
        rsip_match = re.search(regex_obj.re_sip, nmap_output)
        wsdapi_match = re.search(regex_obj.re_wsdapi, nmap_output)
        dfsr_match = re.search(regex_obj.re_dfsr, nmap_output)
        wrms_match = re.search(regex_obj.re_wrms, nmap_output)

        ''' TCP port matches '''
        # If a ftp port is open #
        if ftp_match:
            # If port 20 in match result #
            if '20' in ftp_match.group(0):
                port = 20
            # If port 21 in match result #
            else:
                port = 21

            # Execute yaml commands for ftp #
            ftp_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If ssh port is open #
        if ssh_match:
            # Execute yaml commands for ssh #
            ssh_handler(target_ip, base_path, 22, configs_obj, logger_queue)

        # If telnet port is open #
        if telnet_match:
            # Execute yaml commands for telnet #
            telnet_handler(target_ip, base_path, 23, configs_obj, logger_queue)

        # If a SMTP port is open #
        if smtp_match:
            # If port 25 in match result #
            if '25' in smtp_match.group(0):
                port = 25
            # If port 465 in match result #
            elif '465' in smtp_match.group(0):
                port = 465
            # If port 587 in match result #
            elif '587' in smtp_match.group(0):
                port = 587
            # If port 2525 in match result #
            else:
                port = 2525

            # Execute yaml commands for smtp #
            smtp_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If finger port is open #
        if finger_match:
            # Execute yaml commands for finger #
            finger_handler(target_ip, base_path, 79, configs_obj, logger_queue)

        # If a http(s) port is open #
        if web_match:
            # If port 80 in match result #
            if '80' in web_match.group(0):
                port = 80
            # If port 443 in match result #
            elif '443' in web_match.group(0):
                port = 443
            # If port 8080 in match result #
            elif '8080' in web_match.group(0):
                port = 8080
            # If port 8443 in match result #
            else:
                port = 8443

            # Execute yaml commands for web #
            web_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a pop3 port is open #
        if pop3_match:
            # If port 110 in match result #
            if '110' in pop3_match.group(0):
                port = 110
            # If port 995 in match result #
            else:
                port = 995

            # Execute yaml commands for pop3 #
            pop3_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a nntp port is open #
        if nntp_match:
            # If port 119 in match result #
            if '119' in nntp_match.group(0):
                port = 119
            # If port 443 in match result #
            else:
                port = 443

            # Execute yaml commands for nntp #
            nntp_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a imap port is open #
        if imap_match:
            # If port 143 in match result #
            if '143' in imap_match.group(0):
                port = 143
            # If port 993 in match result #
            else:
                port = 993

            # Execute yaml commands for imap #
            imap_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If smux port is open #
        if smux_match:
            # Execute yaml commands for smux #
            smux_handler(target_ip, base_path, 199, configs_obj, logger_queue)

        # If smb port is open #
        if smb_match:
            # Execute yaml commands for smb #
            smb_handler(target_ip, base_path, 445, configs_obj, logger_queue)

        # If rtsp port is open #
        if rtsp_match:
            # Execute yaml commands for rtsp #
            rtsp_handler(target_ip, base_path, 554, configs_obj, logger_queue)

        # If cups port is open #
        if cups_match:
            # Execute yaml commands for cups #
            cups_handler(target_ip, base_path, 631, configs_obj, logger_queue)

        # If kerberos v5 admin tcp port is open #
        if kerbv5_admin_tcp_match:
            # Execute yaml commands for kerberos v5 admin tcp #
            kerbv5_admin_tcp(target_ip, base_path, 749, configs_obj, logger_queue)

        # If kerberos v4 passwd tcp port is open #
        if kerbv4_passwd_tcp_match:
            # Execute yaml commands for kerberos v4 passwd tcp #
            kerbv4_passwd_tcp(target_ip, base_path, 761, configs_obj, logger_queue)

        # If rsync port is open #
        if rsync_match:
            # Execute yaml commands for rsync #
            rsync_handler(target_ip, base_path, 873, configs_obj, logger_queue)

        # If iis port is open #
        if iss_match:
            # Execute yaml commands for iis #
            iis_handler(target_ip, base_path, 1025, configs_obj, logger_queue)

        # If mssql port is open #
        if mssql_match:
            # Execute yaml commands for mssql #
            mssql_handler(target_ip, base_path, 1433, configs_obj, logger_queue)

        # If oracle db port is open #
        if oracle_db_match:
            # Execute yaml commands for oracle db #
            oracle_db_handler(target_ip, base_path, 1521, configs_obj, logger_queue)

        # If oracle xml db port is open #
        if oracle_xmldb_match:
            # Execute yaml commands for oracle xml db #
            oracle_xmldb_handler(target_ip, base_path, 2100, configs_obj, logger_queue)

        # If mysql port is open #
        if sql_match:
            # Execute yaml commands sql #
            sql_handler(target_ip, base_path, 3306, configs_obj, logger_queue)

        # If oracle web port is open #
        if oracle_web_match:
            # Execute yaml commands for oracle web #
            oracle_web_handler(target_ip, base_path, 3339, configs_obj, logger_queue)

        # If rdp port is open #
        if rdp_match:
            # Execute yaml commands for rdp #
            rdp_handler(target_ip, base_path, 3389, configs_obj, logger_queue)

        # If a adb port is open #
        if adb_match:
            # If port 5037 in match result #
            if '5037' in adb_match.group(0):
                port = 5037
            # If port 5555 in match result #
            else:
                port = 5555

            # Execute yaml commands for adb #
            adb_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a vnc port is open #
        if vnc_match:
            # If port 5800 in match result #
            if '5800' in vnc_match.group(0):
                port = 5800
            # If port 5900 in match result #
            else:
                port = 5900

            # Execute yaml commands for vnc #
            vnc_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a winrm port is open #
        if winrm_match:
            # If port 5985 in match result #
            if '5985' in winrm_match.group(0):
                port = 5985
            # If port 5986 in match result #
            else:
                port = 5986

            # Execute yaml commands for winrm #
            winrm_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If active directory admin center port is open #
        if ad_admin_match:
            # Execute yaml commands for ad admin center #
            ad_admin_handler(target_ip, base_path, 9389, configs_obj, logger_queue)

        ''' UDP port matches '''
        # If dhcp port is open #
        if dhcp_match:
            # Execute yaml commands for dhcp #
            dhcp_handler(target_ip, base_path, 67, configs_obj, logger_queue)

        # If tftp port is open #
        if tftp_match:
            # Execute yaml commands for tftp #
            tftp_handler(target_ip, base_path, 69, configs_obj, logger_queue)

        # If kerberos v5 passwd udp port is open #
        if kerbv5_passwd_udp_match:
            # Execute yaml commands for kerberos v5 passwd udp #
            kerbv5_passwd_udp_handler(target_ip, base_path, 464, configs_obj, logger_queue)

        # If kerberos v5 ticket udp port is open #
        if kerbv5_ticket_udp_match:
            # Execute yaml commands for kerberos v5 ticket udp #
            kerbv5_ticket_udp_handler(target_ip, base_path, 4444, configs_obj, logger_queue)

        # If multicast dns port is open #
        if mdns_match:
            # Execute yaml commands for mdns #
            mdns_handler(target_ip, base_path, 5353, configs_obj, logger_queue)

        ''' TCP/UDP port matches '''
        # If wins port is open #
        if wins_match:
            # Execute yaml commands for wins #
            wins_handler(target_ip, base_path, 42, configs_obj, logger_queue)

        # If dns port is open #
        if dns_match:
            # Execute yaml commands for dns #
            dns_handler(target_ip, base_path, 53, configs_obj, logger_queue)

        # If kerberos v5 ticket port is open #
        if kerbv5_ticket_match:
            # Execute yaml commands for kerberos v5 ticket #
            kerbv5_ticket_handler(target_ip, base_path, 88, configs_obj, logger_queue)

        # If rpc port is open #
        if rpc_match:
            # Execute yaml commands for rpc #
            rpc_handler(target_ip, base_path, 111, configs_obj, logger_queue)

        # If ntp port is open #
        if ntp_match:
            # Execute yaml commands for ntp #
            ntp_handler(target_ip, base_path, 123, configs_obj, logger_queue)

        # If msrpc port is open #
        if msrpc_match:
            # Execute yaml commands for msrpc #
            msrpc_handler(target_ip, base_path, 135, configs_obj, logger_queue)

        # If netbios name port is open #
        if netbios_name_match:
            # Execute yaml commands for netbios name #
            netbios_name_handler(target_ip, base_path, 137, configs_obj, logger_queue)

        # If netbios session port is open #
        if netbios_sesh_match:
            # Execute yaml commands for netbios session #
            netbios_sesh_handler(target_ip, base_path, 139, configs_obj, logger_queue)

        # If a snmp port is open #
        if snmp_match:
            # If port 161 in match result #
            if '161' in snmp_match.group(0):
                port = 161
            # If port 162 in match result #
            elif '162' in snmp_match.group(0):
                port = 162
            # If port 10161 in match result #
            elif '10161' in snmp_match.group(0):
                port = 10161
            # If port 10162 in match result #
            else:
                port = 10162

            # Execute yaml commands for snmp #
            snmp_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a ldap port is open #
        if ldap_match:
            # If port 389 in match result #
            if '389' in ldap_match.group(0):
                port = 389
            # If port 636 in match result #
            else:
                port = 636

            # Execute yaml commands for ldap #
            ldap_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If kerberos v4 ticket port is open #
        if kerbv4_ticket_match:
            # Execute yaml commands for kerberos v4 ticket #
            kerbv4_ticket_handler(target_ip, base_path, 750, configs_obj, logger_queue)

        # If kerberos v4 admin port is open #
        if kerbv4_admin_match:
            # Execute yaml commands for kerberos v4 admin #
            kerbv4_admin_handler(target_ip, base_path, 751, configs_obj, logger_queue)

        # If a port indicating windows domain is open #
        if windomain_indicator_match:
            # If port 1030 in match result #
            if '1030' in windomain_indicator_match.group(0):
                port = 1030
            # If port 1032 in match result #
            elif '1032' in windomain_indicator_match.group(0):
                port = 1032
            # If port 1033 in match result #
            elif '1033' in windomain_indicator_match.group(0):
                port = 1033
            # If port 1038 in match result #
            else:
                port = 1038

            # Execute yaml commands for windomain #
            windomain_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If a oracle intelligent port is open
        if oracle_agent_match:
            # If port 1748 in match result #
            if '1748' in oracle_agent_match.group(0):
                port = 1748
            # If port 1754 in match result #
            elif '1754' in oracle_agent_match.group(0):
                port = 1754
            # If port 1808 in match result #
            elif '1808' in oracle_agent_match.group(0):
                port = 1808
            # If port 1809 in match result #
            else:
                port = 1809

            # Execute yaml commands for oracle agent #
            oracle_agent_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If nfs port is open #
        if nfs_match:
            # Execute yaml commands for nfs #
            nfs_handler(target_ip, base_path, 2049, configs_obj, logger_queue)

        # If a globalcat ldap port is open #
        if globalcat_ldap_match:
            # If port 3268 in match result #
            if '3268' in globalcat_ldap_match.group(0):
                port = 3268
            # If port 3269 in match result #
            else:
                port = 3269

            # Execute yaml commands for globalcat ldap #
            globalcat_ldap_handler(target_ip, base_path, port, configs_obj, logger_queue)

        # If upnotifyp port is open #
        if upnotifyp_match:
            # Execute yaml commands for upnotifyp #
            upnotifyp_handler(target_ip, base_path, 4445, configs_obj, logger_queue)

        # If rsip port is open #
        if rsip_match:
            # Execute yaml commands for rsip #
            rsip_handler(target_ip, base_path, 4555, configs_obj, logger_queue)

        # If wsdapi port is open #
        if wsdapi_match:
            # Execute yaml commands for wsdapi #
            wsdapi_handler(target_ip, base_path, 5357, configs_obj, logger_queue)

        # If dfsr port is open #
        if dfsr_match:
            # Execute yaml commands for dfsr #
            dfsr_handler(target_ip, base_path, 5722, configs_obj, logger_queue)

        # If wrms port is open #
        if wrms_match:
            # Execute yaml commands for wrms #
            wrms_handler(target_ip, base_path, 47001, configs_obj, logger_queue)

    # If ports already were identified on target #
    else:
        # Iterate through port list from yaml config #
        for port in configs_obj.ports:
            ''' TCP based ports '''
            # If a ftp port in yaml #
            if port in (20, 21):
                # Execute yaml commands for ftp #
                ftp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If ssh port in yaml #
            if port == 22:
                # Execute yaml commands for ssh #
                ssh_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If telnet port in yaml #
            if port == 23:
                # Execute yaml commands for telnet #
                telnet_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If a smtp port in yaml #
            if port in (25, 465, 587, 2525):
                # Execute yaml commands for smtp #
                smtp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If finger port in yaml #
            if port == 79:
                # Execute yaml commands for finger #
                finger_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If a web port in yaml #
            if port in (80, 443, 8080, 8443):
                # Execute yaml commands for web #
                web_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If a pop3 port in yaml #
            if port in (110, 995):
                # Execute yaml commands for pop3 #
                pop3_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If a nntp port in yaml #
            if port in (119, 443):
                # Execute yaml commands for nntp #
                nntp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If a imap port in yaml #
            if port in (143, 993):
                # Execute yaml commands for imap #
                imap_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If smux port in yaml #
            if port == 199:
                # Execute yaml commands for smux #
                smux_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If smb port in yaml #
            if port == 445:
                # Execute yaml commands for smb #
                smb_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If rtsp port in yaml #
            if port == 554:
                # Execute yaml commands for rtsp #
                rtsp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If cups port in yaml #
            if port == 631:
                # Execute yaml commands for cups #
                cups_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v5 admin tcp port from yaml file #
            if port == 749:
                # Execute yaml commands for kerberos v5 admin tcp #
                kerbv5_admin_tcp(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v4 passwd tcp port from yaml file #
            if port == 761:
                # Execute yaml commands for kerberos v4 passwd tcp #
                kerbv4_passwd_tcp(target_ip, base_path, port, configs_obj, logger_queue)

            # If rsync port from yaml #
            if port == 873:
                # Execute yaml commands for rsync #
                rsync_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If iis port from yaml #
            if port == 1025:
                # Execute yaml commands for iis #
                iis_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If mssql port from yaml #
            if port == 1433:
                # Execute yaml commands for mssql #
                mssql_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If oracle db port from yaml #
            if port == 1521:
                # Execute yaml commands for oracle db #
                oracle_db_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If oracle xml db port from yaml #
            if port == 2100:
                # Execute yaml commands for oracle xml db #
                oracle_xmldb_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If sql port from yaml #
            if port == 3306:
                # Execute yaml commands for sql #
                sql_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If oracle web port from yaml #
            if port == 3339:
                # Execute yaml commands for oracle web #
                oracle_web_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If rdp port from yaml #
            if port == 3389:
                # Execute yaml commands for rdp #
                rdp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If android debug port from yaml #
            if port in (5037, 5555):
                # Execute yaml commands for adb #
                adb_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If vnc port from yaml #
            if port in (5800, 5900):
                # Execute yaml commands for vnc #
                vnc_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If winrm port from yaml #
            if port in (5985, 5986):
                # Execute yaml commands for winrm #
                winrm_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If active directory admin center port from yaml #
            if port == 9389:
                # Execute yaml commands for adac #
                ad_admin_handler(target_ip, base_path, port, configs_obj, logger_queue)

            ''' UDP based ports '''
            # If dbcp port from yaml #
            if port == 67:
                # Execute yaml commands for dhcp #
                dhcp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If tftp port from yaml #
            if port == 69:
                # Execute yaml commands for tftp #
                tftp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v5 passwd udp port from yaml #
            if port == 464:
                # Execute yaml commands for kerberos v5 passwd udp #
                kerbv5_passwd_udp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v5 ticket udp port from yaml #
            if port == 4444:
                # Execute yaml commands for kerberos v5 ticket udp #
                kerbv5_ticket_udp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If multicast dns port from yaml #
            if port == 5353:
                # Execute yaml commands for mdns #
                mdns_handler(target_ip, base_path, port, configs_obj, logger_queue)

            ''' TCP/UDP based ports '''
            # If wins port from yaml #
            if port == 42:
                # Execute yaml commands for wins #
                wins_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If dns port from yaml #
            if port == 53:
                # Execute yaml commands for dns #
                dns_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v5 ticket port from yaml #
            if port == 88:
                # Execute yaml commands for kerberos v5 ticket #
                kerbv5_ticket_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If rpc port from yaml #
            if port == 111:
                # Execute yaml commands for rpc #
                rpc_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If ntp port from yaml #
            if port == 123:
                # Execute yaml commands for ntp #
                ntp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If msrpc port from yaml #
            if port == 135:
                # Execute yaml commands for msrpc #
                msrpc_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If netbios name port from yaml #
            if port == 137:
                # Execute yaml commands for netbios name #
                netbios_name_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If netbios session port from yaml #
            if port == 139:
                # Execute yaml commands for netbios session #
                netbios_sesh_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If snmp port from yaml #
            if port in (161, 162, 10161, 10162):
                # Execute yaml commands for snmp #
                snmp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If ldap port from yaml #
            if port in (389, 636):
                # Execute yaml commands for ldap #
                ldap_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v4 ticket port from yaml #
            if port == 750:
                # Execute yaml commands for kerberos v4 ticket #
                kerbv4_ticket_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If kerberos v4 admin port from yaml #
            if port == 751:
                # Execute yaml commands for kerberos v4 admin #
                kerbv4_admin_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If windomain indicator port from yaml #
            if port in (1030, 1032, 1033, 1038):
                # Execute yaml commands for windomain #
                windomain_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If oracle agent port from yaml #
            if port in (1748, 1754, 1808, 1809):
                # Execute yaml commands for oracle agent #
                oracle_agent_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If nfs port from yaml #
            if port == 2049:
                # Execute yaml commands for nfs #
                nfs_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If globalcat ldap port from yaml #
            if port in (3268, 3269):
                # Execute yaml commands for globalcat ldap #
                globalcat_ldap_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If upnotifyp port from yaml #
            if port == 4445:
                # Execute yaml commands for upnotifyp #
                upnotifyp_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If rsip port from yaml #
            if port == 4555:
                # Execute yaml commands for rsip #
                rsip_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If wsdapi port from yaml #
            if port == 5357:
                # Execute yaml commands for wsdapi #
                wsdapi_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If dfsr port from yaml #
            if port == 5722:
                # Execute yaml commands for dfsr #
                dfsr_handler(target_ip, base_path, port, configs_obj, logger_queue)

            # If wrms port from yaml #
            if port == 47001:
                # Execute yaml commands for wrms #
                wrms_handler(target_ip, base_path, port, configs_obj, logger_queue)


def ping_handler(ping_ip: str) -> bytes:
    # Execute ping with current ip in cidr and return results #
    return check_output(['ping', '-c', '4', ping_ip])


def ping_executor(ip_queue: Queue, config: object):
    # Get the app logger #
    logger = logging.getLogger('App')

    try:
        # Establish thread pool executor for ping scan #
        with ThreadPoolExecutor(max_workers=config.ping_threads) as executor:
            # Set up futures with each ip target in cidr range #
            future_to_ping = {executor.submit(ping_handler, str(ip)): ip for ip in
                              ipaddress.IPv4Network(config.cidr)}
            # Iterate through futures and get the results #
            for future in concurrent.futures.as_completed(future_to_ping):
                # Get result data from ping command #
                data = future.result()

                # If TTL in results meaning successful #
                if b'TTL' in data:
                    # Get the ip for current future #
                    ip = future_to_ping[future]
                    # Add the ip to the ip queue #
                    ip_queue.put(ip)

    # If there is an error with ThreadPoolExecutor #
    except BrokenExecutor as exec_err:
        # Print error, log, and exit #
        print_err(f'Error occurred with thread pool executor during ping scan: {exec_err}')
        logger.error('Error occurred with thread pool executor during ping scan: %s\n\n', exec_err)
        sys.exit(3)

    return ip_queue


def main():
    """
    Loads the config file, runs ping scan to get hosts if subnet scan specified, and launches the
    scan process on target hosts based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_queue = Queue()
    joined_procs = []

    # Compile program regex and return as object #
    re_obj = CompiledRegex()

    # If potential yaml config file passed into to program #
    if len(sys.argv) > 1:
        # Format passed in argument as path #
        config_path = cwd / 'Configs' / sys.argv[1]

        # If the passed in configuration file does not exist or is not a yaml file #
        if not config_path.exists() or not str(config_path).endswith('yml'):
            # Prompt user for yaml config file #
            config_path = config_input(cwd)

    # If no args were passed in #
    else:
        # Prompt user for yaml config file #
        config_path = config_input(cwd)

    # Load the YAML configuration file #
    config_data = file_handler(config_path, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue if they are proper ip addresses #
        [hosts.put(host) for host in config_obj.hosts if re.search(re_obj.re_ip, host)]

    # If CIDR network range is specified #
    elif config_obj.cidr:
        # If the provided cidr network in yaml is not properly formatted #
        if not re.search(re_obj.re_cidr, config_obj.cidr):
            print_err('Improper cidr network formatting in yaml config file')
            sys.exit(2)

        # Run ping scan of target hosts #
        hosts = ping_executor(hosts, config_obj)

    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    while True:
        # Iterate through join list #
        for proc in joined_procs:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from join list #
                joined_procs.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not joined_procs:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, out_dir, config_obj,
                                                         log_queue))
            # Start process and put in process queue #
            process.start()
            proc_queue.put(process)
            num_cpu -= 1

        # While process queue has processes #
        while not proc_queue.empty():
            # Get process from queue and join it #
            process = proc_queue.get()
            process.join()
            # Add process to join list after join #
            joined_procs.append(process)


def log_handler(logger_queue: Queue):
    # Get the logger instance #
    logger = logging.getLogger('App')

    while True:
        # Get log message from queue and log to file #
        log_message = logger_queue.get()
        logger.handle(log_message)


if __name__ == '__main__':
    RET = 0
    log_queue = Queue()

    # Get the current working directory #
    cwd = Path.cwd()
    # Format the output directory #
    out_dir = cwd / 'Output'

    # If the output dir does not exist #
    if not out_dir.exists():
        # Create the output dir #
        out_dir.mkdir(parents=True)

    # Format path to log file #
    log_path = cwd / 'pentester_toolchain.log'

    # Set the log file name #
    logging.basicConfig(filename=log_path, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    # Get the logger instance #
    log_obj = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    log_obj.addHandler(log_queue)

    # Start background logging thread #
    log_thread = threading.Thread(target=log_handler, args=(log_queue,), daemon=True)
    log_thread.start()

    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        log_obj.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    # Print and log total execution time #
    print(f'\n[!] Execution time: {exec_time}')
    log_obj.info('Execution time: %s\n\n', exec_time)
    # Sleep second to ensure logging thread logs info before exit #
    time.sleep(1)

    sys.exit(RET)
