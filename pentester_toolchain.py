""" Built-in modules """
import logging
import re
import sys
import threading
import time
from concurrent.futures import BrokenExecutor, ThreadPoolExecutor
from multiprocessing import cpu_count, Process
from pathlib import Path
from queue import Queue
# Custom Modules #
from Modules.tcp_handlers import ftp_handler, ssh_handler, telnet_handler, smtp_handler, \
                                 finger_handler, web_handler, pop3_handler, nntp_handler, \
                                 imap_handler, smux_handler, smb_handler, rtsp_handler, \
                                 cups_handler, kerbv5_admin_tcp, kerbv4_passwd_tcp, rsync_handler, \
                                 iis_handler, mssql_handler, oracle_db_handler, \
                                 oracle_xmldb_handler, sql_handler, oracle_web_handler, \
                                 rdp_handler, adb_handler, vnc_handler, winrm_handler, \
                                 ad_admin_handler

from Modules.udp_handlers import dhcp_handler, tftp_handler, kerbv5_passwd_udp_handler, \
                                 kerbv5_ticket_udp_handler, mdns_handler
from Modules.utils import CompiledRegex, ConfigClass, config_input, file_handler, print_err


# Global variables #
THREAD_LOCAL = threading.local()

def scan_process(target_ip: str, regex_obj: object, base_path: Path, configs_obj: object,
                 logger_queue: Queue):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param base_path:  Path to the base directory of the project.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :param logger_queue:  The queue used for handling inter-process logging.
    :return:  Nothing
    """
    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        # TODO add in nmap scan
        file_path = cwd / 'nmapSampleOutputs' / 'blueprint_nmapOut.txt'
        # Read the nmap scan output #
        nmap_output = file_handler(file_path, 'r')

        # TCP port regex matches #
        ftp_match = re.search(regex_obj.re_ftp, nmap_output)
        ssh_match = re.search(regex_obj.re_ssh, nmap_output)
        telnet_match = re.search(regex_obj.re_telnet, nmap_output)
        smtp_match = re.search(regex_obj.re_smtp, nmap_output)
        finger_match = re.search(regex_obj.re_finger, nmap_output)
        web_match = re.search(regex_obj.re_web, nmap_output)
        pop3_match = re.search(regex_obj.re_pop3, nmap_output)
        nntp_match = re.search(regex_obj.re_nntp, nmap_output)
        imap_match = re.search(regex_obj.re_imap, nmap_output)
        smux_match = re.search(regex_obj.re_smux, nmap_output)
        smb_match = re.search(regex_obj.re_smb, nmap_output)
        rtsp_match = re.search(regex_obj.re_rtsp, nmap_output)
        cups_match = re.search(regex_obj.re_cups, nmap_output)
        kerbv5_admin_tcp_match = re.search(regex_obj.re_kerbv5_admin_tcp, nmap_output)
        kerbv4_passwd_tcp_match = re.search(regex_obj.re_kerbv4_passwd_tcp, nmap_output)
        rsync_match = re.search(regex_obj.re_rsync, nmap_output)
        iss_match = re.search(regex_obj.re_iss, nmap_output)
        mssql_match = re.search(regex_obj.re_mssql, nmap_output)
        oracle_db_match = re.search(regex_obj.re_oracle_db, nmap_output)
        oracle_xmldb_match = re.search(regex_obj.re_oracle_xmldb, nmap_output)
        sql_match = re.search(regex_obj.re_sql, nmap_output)
        oracle_web_match = re.search(regex_obj.re_oracle_web, nmap_output)
        rdp_match = re.search(regex_obj.re_rdp, nmap_output)
        adb_match = re.search(regex_obj.re_adb, nmap_output)
        vnc_match = re.search(regex_obj.re_vnc, nmap_output)
        winrm_match = re.search(regex_obj.re_winrm, nmap_output)
        ad_admin_match = re.search(regex_obj.re_ad_admin, nmap_output)

        # UDP port regex matches #
        dhcp_match = re.search(regex_obj.re_dhcp, nmap_output)
        tftp_match = re.search(regex_obj.re_tftp, nmap_output)
        kerbv5_passwd_udp_match = re.search(regex_obj.re_kerbv5_passwd_udp, nmap_output)
        kerbv5_ticket_udp_match = re.search(regex_obj.re_kerbv5_ticket_conv_udp, nmap_output)
        mdns_match = re.search(regex_obj.re_mdns, nmap_output)

        # TCP/UDP port regex matches #
        wins_match = re.search(regex_obj.re_wins, nmap_output)
        dns_match = re.search(regex_obj.re_dns, nmap_output)
        kerbv5_ticket_match = re.search(regex_obj.re_kerbv5_ticket, nmap_output)
        rpc_match = re.search(regex_obj.re_rpc, nmap_output)
        ntp_match = re.search(regex_obj.re_ntp, nmap_output)
        msrpc_match = re.search(regex_obj.re_msrpc, nmap_output)
        netbios_name_match = re.search(regex_obj.re_netbios_name, nmap_output)
        netbios_sesh_match = re.search(regex_obj.re_netbios_sesh, nmap_output)
        snmp_match = re.search(regex_obj.re_snmp, nmap_output)
        ldap_match = re.search(regex_obj.re_ldap, nmap_output)
        kerbv4_ticket_match = re.search(regex_obj.re_kerbv4_ticket, nmap_output)
        kerbv4_admin_match = re.search(regex_obj.re_kerbv4_admin, nmap_output)
        windomain_indicator_match = re.search(regex_obj.re_windomain_indicator, nmap_output)
        oracle_agent_match = re.search(regex_obj.re_oracle_agent, nmap_output)
        nfs_match = re.search(regex_obj.re_nfs, nmap_output)
        globalcat_ldap_match = re.search(regex_obj.re_globalcat_ldap, nmap_output)
        upnotifyp_match = re.search(regex_obj.re_upnotifyp, nmap_output)
        rsip_match = re.search(regex_obj.re_sip, nmap_output)
        wsdapi_match = re.search(regex_obj.re_wsdapi, nmap_output)
        dfsr_match = re.search(regex_obj.re_dfsr, nmap_output)
        wrms_match = re.search(regex_obj.re_wrms, nmap_output)

        ''' TCP port matches '''
        # If a ftp port is open #
        if ftp_match:
            # If port 20 in match result #
            if '20' in ftp_match.group(0):
                port = 20
            # If port 21 in match result #
            else:
                port = 21

            # Execute yaml commands for ftp #
            ftp_handler(port, configs_obj)

        # If ssh port is open #
        if ssh_match:
            # Execute yaml commands for ssh #
            ssh_handler(22, configs_obj)

        # If telnet port is open #
        if telnet_match:
            # Execute yaml commands for telnet #
            telnet_handler(23, configs_obj)

        # If a SMTP port is open #
        if smtp_match:
            # If port 25 in match result #
            if '25' in smtp_match.group(0):
                port = 25
            # If port 465 in match result #
            elif '465' in smtp_match.group(0):
                port = 465
            # If port 587 in match result #
            elif '587' in smtp_match.group(0):
                port = 587
            # If port 2525 in match result #
            else:
                port = 2525

            # Execute yaml commands for smtp #
            smtp_handler(port, configs_obj)

        # If finger port is open #
        if finger_match:
            # Execute yaml commands for finger #
            finger_handler(79, configs_obj)

        # If a http(s) port is open #
        if web_match:
            # If port 80 in match result #
            if '80' in web_match.group(0):
                port = 80
            # If port 443 in match result #
            elif '443' in web_match.group(0):
                port = 443
            # If port 8080 in match result #
            elif '8080' in web_match.group(0):
                port = 8080
            # If port 8443 in match result #
            else:
                port = 8443

            # Execute yaml commands for web #
            web_handler(port, configs_obj)

        # If a pop3 port is open #
        if pop3_match:
            # If port 110 in match result #
            if '110' in pop3_match.group(0):
                port = 110
            # If port 995 in match result #
            else:
                port = 995

            # Execute yaml commands for pop3 #
            pop3_handler(port, configs_obj)

        # If a nntp port is open #
        if nntp_match:
            # If port 119 in match result #
            if '119' in nntp_match.group(0):
                port = 119
            # If port 443 in match result #
            else:
                port = 443

            # Execute yaml commands for nntp #
            nntp_handler(port, configs_obj)

        # If a imap port is open #
        if imap_match:
            # If port 143 in match result #
            if '143' in imap_match.group(0):
                port = 143
            # If port 993 in match result #
            else:
                port = 993

            # Execute yaml commands for imap #
            imap_handler(port, configs_obj)

        # If smux port is open #
        if smux_match:
            # Execute yaml commands for smux #
            smux_handler(199, configs_obj)

        # If smb port is open #
        if smb_match:
            # Execute yaml commands for smb #
            smb_handler(445, configs_obj)

        # If rtsp port is open #
        if rtsp_match:
            # Execute yaml commands for rtsp #
            rtsp_handler(554, configs_obj)

        # If cups port is open #
        if cups_match:
            # Execute yaml commands for cups #
            cups_handler(631, configs_obj)

        # If kerberos v5 admin tcp port is open #
        if kerbv5_admin_tcp_match:
            # Execute yaml commands for kerberos v5 admin tcp #
            kerbv5_admin_tcp(749, configs_obj)

        # If kerberos v4 passwd tcp port is open #
        if kerbv4_passwd_tcp_match:
            # Execute yaml commands for kerberos v4 passwd tcp #
            kerbv4_passwd_tcp(761, configs_obj)

        # If rsync port is open #
        if rsync_match:
            # Execute yaml commands for rsync #
            rsync_handler(873, configs_obj)

        # If iis port is open #
        if iss_match:
            # Execute yaml commands for iis #
            iis_handler(1025, configs_obj)

        # If mssql port is open #
        if mssql_match:
            # Execute yaml commands for mssql #
            mssql_handler(1433, configs_obj)

        # If oracle db port is open #
        if oracle_db_match:
            # Execute yaml commands for oracle db #
            oracle_db_handler(1521, configs_obj)

        # If oracle xml db port is open #
        if oracle_xmldb_match:
            # Execute yaml commands for oracle xml db #
            oracle_xmldb_handler(2100, configs_obj)

        # If mysql port is open #
        if sql_match:
            # Execute yaml commands sql #
            sql_handler(3306, configs_obj)

        # If oracle web port is open #
        if oracle_web_match:
            # Execute yaml commands for oracle web #
            oracle_web_handler(3339, configs_obj)

        # If rdp port is open #
        if rdp_match:
            # Execute yaml commands for rdp #
            rdp_handler(3389, configs_obj)

        # If a adb port is open #
        if adb_match:
            # If port 5037 in match result #
            if '5037' in adb_match.group(0):
                port = 5037
            # If port 5555 in match result #
            else:
                port = 5555

            # Execute yaml commands for adb #
            adb_handler(port, configs_obj)

        # If a vnc port is open #
        if vnc_match:
            # If port 5800 in match result #
            if '5800' in vnc_match.group(0):
                port = 5800
            # If port 5900 in match result #
            else:
                port = 5900

            # Execute yaml commands for vnc #
            vnc_handler(port, configs_obj)

        # If a winrm port is open #
        if winrm_match:
            # If port 5985 in match result #
            if '5985' in winrm_match.group(0):
                port = 5985
            # If port 5986 in match result #
            else:
                port = 5986

            # Execute yaml commands for winrm #
            winrm_handler(port, configs_obj)

        # If active directory admin center port is open #
        if ad_admin_match:
            # Execute yaml commands for ad admin center #
            ad_admin_handler(9389, configs_obj)

        ''' UDP port matches '''
        # If dhcp port is open #
        if dhcp_match:
            # Execute yaml commands for dhcp #
            dhcp_handler(67, configs_obj)

        # If tftp port is open #
        if tftp_match:
            # Execute yaml commands for tftp #
            tftp_handler(69, configs_obj)

        # If kerberos v5 passwd udp port is open #
        if kerbv5_passwd_udp_match:
            # Execute yaml commands for kerberos v5 passwd udp #
            kerbv5_passwd_udp_handler(464, configs_obj)

        # If kerberos v5 ticket udp port is open #
        if kerbv5_ticket_udp_match:
            # Execute yaml commands for kerberos v5 ticket udp #
            kerbv5_ticket_udp_handler(4444, configs_obj)

        # If multicast dns port is open #
        if mdns_match:
            # Execute yaml commands for mdns #
            mdns_handler(5353, configs_obj)

        ''' TCP/UDP port matches '''
        # If wins port is open #
        if wins_match:
            # Iterate through wins commands from yaml file #
            for command in configs_obj.wins:
                pass

        # If dns port is open #
        if dns_match:
            # TODO potentially find out whether tcp or udp

            # Iterate through dns commands from yaml file #
            for command in configs_obj.dns:
                pass

        # If kerberos v5 ticket port is open #
        if kerbv5_ticket_match:
            # Iterate through kerberos v5 ticket commands from yaml file #
            for command in configs_obj.kerberos_v5_ticket:
                pass

        # If rpc port is open #
        if rpc_match:
            # Iterate through rpc commands from yaml file #
            for command in configs_obj.rpc:
                pass

        # If ntp port is open #
        if ntp_match:
            # Iterate through ntp commands from yaml file #
            for command in configs_obj.ntp:
                pass

        # If msrpc port is open #
        if msrpc_match:
            # Iterate through msrpc commands from yaml file #
            for command in configs_obj.msrpc:
                pass

        # If netbios name port is open #
        if netbios_name_match:
            # Iterate through netbios name commands from yaml file #
            for command in configs_obj.netbios_name:
                pass

        # If netbios session port is open #
        if netbios_sesh_match:
            # Iterate through netbios session commands from yaml file #
            for command in configs_obj.netbios_sesh:
                pass

        # If a snmp port is open #
        if snmp_match:
            # TODO find out what port matched

            # Iterate through snmp commands from yaml file #
            for command in configs_obj.snmp:
                pass

        # If a ldap port is open #
        if ldap_match:
            # TODO find out what port matched

            # Iterate through ldap commands from yaml file #
            for command in configs_obj.ldap:
                pass

        # If kerberos v4 ticket port is open #
        if kerbv4_ticket_match:
            # Iterate through kerberos v5 ticket commands from yaml file #
            for command in configs_obj.kerberos_v4_ticket:
                pass

        # If kerberos v4 admin port is open #
        if kerbv4_admin_match:
            # Iterate through kerberos v4 admin commands from yaml file #
            for command in configs_obj.kerberos_v4_admin:
                pass

        # If a port indicating windows domain is open #
        if windomain_indicator_match:
            # TODO find out what port matched

            # Iterate through windows domain commands from yaml file #
            for command in configs_obj.windomain_indicator:
                pass

        # If a oracle intelligent port is open
        if oracle_agent_match:
            # TODO find out what port matched

            # Iterate through oracle agent commands from yaml file #
            for command in configs_obj.oracle_agent:
                pass

        # If nfs port is open #
        if nfs_match:
            # Iterate through nfs commands from yaml file #
            for command in configs_obj.nfs:
                pass

        # If a globalcat ldap port is open #
        if globalcat_ldap_match:
            # TODO find out what port matched

            # Iterate through globalcat ldap commands from yaml file #
            for command in configs_obj.globalcat_ldap:
                pass

        # If upnotifyp port is open #
        if upnotifyp_match:
            # Iterate through upnotifyp commands from yaml file #
            for command in configs_obj.upnotifyp:
                pass

        # If rsip port is open #
        if rsip_match:
            # Iterate through rsip commands from yaml file #
            for command in configs_obj.rsip:
                pass

        # If wsdapi port is open #
        if wsdapi_match:
            # Iterate through wsdapi commands from yaml file #
            for command in configs_obj.wsdapi:
                pass

        # If dfsr port is open #
        if dfsr_match:
            # Iterate through dfsr commands from yaml file #
            for command in configs_obj.dfsr:
                pass

        # If wrms port is open #
        if wrms_match:
            # Iterate through wrms commands from yaml file #
            for command in configs_obj.wrms:
                pass

    # If ports already were identified on target #
    else:
        # Iterate through port list from yaml config #
        for port in configs_obj.ports:
            ''' TCP based ports '''
            # If a ftp port in yaml #
            if port in (20, 21):
                # Iterate through ftp commands from yaml file #
                for commnd in configs_obj.ftp:
                    pass

            # If ssh port in yaml #
            if port == 22:
                # Iterate through ssh commands from yaml file #
                for command in configs_obj.ssh:
                    pass

            # If telnet port in yaml #
            if port == 23:
                # Iterate through telnet commands from yaml file #
                for command in configs_obj.telnet:
                    pass

            # If a smtp port in yaml #
            if port in (25, 465, 587, 2525):
                # Iterate through smtp commands from yaml file #
                for command in configs_obj.smtp:
                    pass

            # If finger port in yaml #
            if port == 79:
                # Iterate through finger commands from yaml file #
                for command in configs_obj.finger:
                    pass

            # If a web port in yaml #
            if port in (80, 443, 8080, 8443):
                # Iterate through finger commands from yaml file #
                for command in configs_obj.web:
                    pass

            # If a pop3 port in yaml #
            if port in (110, 995):
                # Iterate through finger commands from yaml file #
                for command in configs_obj.pop3:
                    pass

            # If a nntp port in yaml #
            if port in (119, 443):
                # Iterate through nntp commands from yaml file #
                for command in configs_obj.nntp:
                    pass

            # If a imap port in yaml #
            if port in (143, 993):
                # Iterate through imap commands from yaml file #
                for command in configs_obj.imap:
                    pass

            # If smux port in yaml #
            if port == 199:
                # Iterate through smux commands from yaml file #
                for command in configs_obj.smux:
                    pass

            # If smb port in yaml #
            if port == 445:
                # Iterate through smb commands from yaml file #
                for command in configs_obj.smb:
                    pass

            # If rtsp port in yaml #
            if port == 554:
                # Iterate through rtsp commands from yaml file #
                for command in configs_obj.rtsp:
                    pass

            # If cups port in yaml #
            if port == 631:
                # Iterate through cups commands from yaml file #
                for command in configs_obj.cups:
                    pass

            # If kerberos v5 admin tcp port from yaml file #
            if port == 749:
                # Iterate through kerberos v5 admin tcp commands from yaml file #
                for command in configs_obj.kerberos_v5_admin:
                    pass

            # If kerberos v4 passwd tcp port from yaml file #
            if port == 761:
                pass


def ping_handler(addr_queue: Queue):
    # TODO: Parse input into ping able range and execute through ThreadPoolExecutor
    return addr_queue


def log_handler(logger_queue: Queue):
    # Get the logger instance #
    logger = logging.getLogger('App')

    while True:
        # Get log message from queue and log to file #
        log_message = logger_queue.get()
        logger.handle(log_message)


def main():
    """
    Loads the config file, runs ping scan to get hosts if subnet scan specified, and launches the
    scan process on target hosts based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_queue = Queue()
    joined_procs = []

    # Compile program regex and return as object #
    re_obj = CompiledRegex()

    # If potential yaml config file passed into to program #
    if len(sys.argv) > 1:
        # Format passed in argument as path #
        config_path = cwd / sys.argv[1]

        # If the passed in configuration file does not exist or is not a yaml file #
        if not config_path.exists() or not str(config_path).endswith('yml'):
            # Prompt user for yaml config file #
            config_path = config_input(cwd)

    # If no args were passed in #
    else:
        # Prompt user for yaml config file #
        config_path = config_input(cwd)

    # Load the YAML configuration file #
    config_data = file_handler(config_path, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue #
        [hosts.put(host) for host in config_obj.hosts]
    # If CIDR network range is specified #
    elif config_obj.cidr:
        # Run ping scan of target hosts #
        hosts = ping_handler(hosts)
    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    while True:
        # Iterate through join list #
        for proc in joined_procs:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from join list #
                joined_procs.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not joined_procs:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, cwd, config_obj,
                                                         log_queue))
            # Start process and put in process queue #
            process.start()
            proc_queue.put(process)
            num_cpu -= 1

        # While process queue has processes #
        while not proc_queue.empty():
            # Get process from queue and join it #
            process = proc_queue.get()
            process.join()
            # Add process to join list after join #
            joined_procs.append(process)


if __name__ == '__main__':
    RET = 0
    log_queue = Queue()

    # Get the current working directory #
    cwd = Path.cwd()
    # Format path to log file #
    log_path = cwd / 'pentester_toolchain.log'

    # Set the log file name #
    logging.basicConfig(filename=log_path, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    # Get the logger instance #
    log_obj = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    log_obj.addHandler(log_queue)

    # Start background logging thread #
    log_thread = threading.Thread(target=log_handler, args=(log_queue,), daemon=True)
    log_thread.start()

    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        log_obj.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    # Print and log total execution time #
    print(f'\n[!] Execution time: {exec_time}')
    log_obj.info('Execution time: %s\n\n', exec_time)
    # Sleep half second to ensure logging thread logs info before exit #
    time.sleep(0.5)

    sys.exit(RET)
