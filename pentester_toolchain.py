""" Built-in modules """
import logging
import re
import sys
import threading
import time
from logging.handlers import QueueHandler
from multiprocessing import cpu_count, get_logger, Process, Queue
from pathlib import Path
# Custom Modules #
from Modules.utils import cmd_parser, ConfigClass, config_input, file_handler, locked_print, \
                          print_err, RegexHandler, system_cmd
from Modules.tcp_handlers import ftp_handler, ssh_handler, telnet_handler, smtp_handler, \
                                 finger_handler, web_handler, pop3_handler, nntp_handler, \
                                 imap_handler, smux_handler, smb_handler, rtsp_handler, \
                                 cups_handler, kerbv5_admin_tcp_handler, kerbv4_passwd_tcp_handler,\
                                 rsync_handler, iis_handler, mssql_handler, oracle_db_handler, \
                                 oracle_xmldb_handler, sql_handler, oracle_web_handler, \
                                 rdp_handler, adb_handler, vnc_handler, winrm_handler, \
                                 ad_admin_handler
from Modules.tcp_udp_handlers import wins_handler, dns_handler, kerbv5_ticket_handler, \
                                     rpc_handler, ntp_handler, msrpc_handler, \
                                     netbios_name_handler, netbios_sesh_handler, snmp_handler, \
                                     ldap_handler, kerbv4_ticket_handler, kerbv4_admin_handler, \
                                     windomain_handler, oracle_agent_handler, nfs_handler, \
                                     globalcat_ldap_handler, upnotifyp_handler, rsip_handler, \
                                     wsdapi_handler, dfsr_handler, wrms_handler
from Modules.udp_handlers import dhcp_handler, tftp_handler, kerbv5_passwd_udp_handler, \
                                 kerbv5_ticket_udp_handler, mdns_handler


def scan_process(target_ip: str, regex_obj: object, base_path: Path, configs_obj: object,
                 scanner: object, logger_queue: Queue):
    """
    Begins by setting up process logging facilities, file paths, and directories. If there are no
    specified ports in config file, nmap scans will be skipped assuming the ports have already been
    enumerated. Otherwise, an initial nmap scan is run, followed by corresponding tool chains
    configured based on regex matching of open ports, finishing with a full nmap scan checking all
    ports.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param base_path:  Path to the base directory for the project output.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :param scanner:  The program scan process service function class.
    :param logger_queue:  The queue used for handling inter-process logging.
    :return:  Nothing
    """
    # Get logging instance #
    logger = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    logger.addHandler(QueueHandler(logger_queue))
    # Set file paths for target directory and nmap scans #
    host_path = base_path / target_ip
    tcp_path = host_path / 'TCP_Handlers'
    udp_path = host_path / 'UDP_Handlers'
    tcp_udp_path = host_path / 'TCP_UDP_Handlers'
    scan_dirs = (host_path, tcp_path, udp_path, tcp_udp_path)

    # Iterate through program directory paths #
    for path in scan_dirs:
        # Create the dir #
        path.mkdir(parents=True, exist_ok=True)

    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        # Set the nmap paths #
        nmap_path = host_path / 'Nmap'
        nmap_start = nmap_path / 'nmap_init.txt'
        nmap_end = nmap_path / 'nmap_full.txt'
        # Create the nmap directory #
        nmap_path.mkdir(parents=True, exist_ok=True)

        # Get the initial nmap port scan syntax from config class #
        yaml_cmd = configs_obj.nmap_init
        # Check and parse the yaml command
        cmd = cmd_parser(yaml_cmd, regex_obj, target_ip)

        locked_print(f'[+] Starting initial nmap scan for {target_ip}')

        # Run the initial nmap scan to enumerate
        # common service ports of interest #
        scan_data = system_cmd(cmd.split(), None, logger)
        # If initial nmap scan was successful #
        if scan_data:
            file_handler(nmap_start, 'wb', data=scan_data)
        # If returned data indicates error #
        else:
            print_err(f'Initial nmap scan returned no data on {target_ip}')
            logger.error('Initial nmap scan returned no data on %s\n\n', target_ip)
            sys.exit(4)

        locked_print(f'[!] Initial nmap scan for {target_ip} completed')

        # Set error code for if not properly referenced in loop #
        scan_port = '-1'
        # Run regex operations on port scan output to find open ports #
        re_searches = regex_obj.scan_parse(scan_data)

        locked_print(f'[+] Attempting to execute command toolchains on {target_ip} based on regex '
                     'matches')

        # Iterate through the regex result from port scan #
        for key, value in re_searches.items():
            # If the regex pattern matched #
            if value:
                # Split any variations of single or comma split ports #
                port_list = key.split(',')

                # Iterate through port list #
                for port in port_list:
                    # If current port found in match #
                    if port in value.group(0):
                        # Assign as scan port & exit loop #
                        scan_port = port
                        break

                # If the scan port was not found #
                if scan_port == '-1':
                    logger.error('Port in %s was not found in %s\n\n', key, value)
                    sys.exit(4)

                try:
                    # Execute service handler function #
                    scanner.service_handler[key](target_ip, scan_dirs, int(scan_port), configs_obj,
                                                 regex_obj, logger)

                # If a key is passed in that does not exist #
                except (KeyError, ValueError) as exec_err:
                    # Log error and exit #
                    logger.error('Attempting to access non-existent key in ScanClass func_dict or '
                                 'error converting port to int: %s\n\n', exec_err)
                    sys.exit(5)

        locked_print(f'[+] Starting final nmap scan for {target_ip}')
        # Get the initial nmap port scan syntax from config class #
        yaml_cmd = configs_obj.nmap_final
        # Check and parse the yaml command
        cmd = cmd_parser(yaml_cmd, regex_obj, target_ip)

        # Run final nmap scan on all uncommon ports #
        scan_data = system_cmd(cmd.split(), None, logger)
        # If the final nmap scan was successful #
        if scan_data:
            # Write nmap data to output file #
            file_handler(nmap_end, 'wb', data=scan_data)

        locked_print(f'[!] Final nmap scan for {target_ip} completed')

    # If ports already were identified on target #
    else:
        locked_print(f'[+] Executing command toolchains on {target_ip} for ports: '
                     f'{configs_obj.ports}')

        # Iterate through port list from yaml config #
        for port in configs_obj.ports:
            # Ensure port is string format #
            str_port = str(port)
            # If the converted string port is not a base10 decimal #
            if not str_port.isdigit():
                # Log error and move to next port #
                logger.error('Port \"%s\" in yaml file is not of base10 decimal format\n\n',
                             str_port)
                continue

            # Iterate through service dict items #
            for key, value in scanner.service_handler.items():
                # If the port is in the current key #
                if str_port in key:
                    try:
                        # Execute service handler function #
                        scanner.service_handler[key](target_ip, scan_dirs, port, configs_obj,
                                                     regex_obj, logger)

                    # If a key is passed in that does not exist #
                    except KeyError as exec_err:
                        logger.error('Attempting to access non-existent key in ScanClass func_dict:'
                                     ' %s\n\n', exec_err)
                        sys.exit(5)

        locked_print(f'[!] Toolchain execution complete for {target_ip}')


class ScanClass:
    """
    The scan process service handler class, which maps the ports of interest to their associated
    service handler function to later be referenced for execution.
    """
    service_handler = {
        # TCP handler functions #
        '20,21': ftp_handler,
        '22': ssh_handler,
        '23': telnet_handler,
        '25,465,587,2525': smtp_handler,
        '79': finger_handler,
        '80,443,8080,8443': web_handler,
        '110,995': pop3_handler,
        '119,433': nntp_handler,
        '143,993': imap_handler,
        '199': smux_handler,
        '445': smb_handler,
        '554': rtsp_handler,
        '631': cups_handler,
        '749': kerbv5_admin_tcp_handler,
        '761': kerbv4_passwd_tcp_handler,
        '873': rsync_handler,
        '1025': iis_handler,
        '1433': mssql_handler,
        '1521': oracle_db_handler,
        '2100': oracle_xmldb_handler,
        '3306': sql_handler,
        '3339': oracle_web_handler,
        '3389': rdp_handler,
        '5037,5555': adb_handler,
        '5800,5900': vnc_handler,
        '5985,5986': winrm_handler,
        '9389': ad_admin_handler,

        # UDP handler functions #
        '67': dhcp_handler,
        '69': tftp_handler,
        '464': kerbv5_passwd_udp_handler,
        '4444': kerbv5_ticket_udp_handler,
        '5353': mdns_handler,

        # TCP/UDP handler functions #
        '42': wins_handler,
        '53': dns_handler,
        '88': kerbv5_ticket_handler,
        '111': rpc_handler,
        '123': ntp_handler,
        '135': msrpc_handler,
        '137': netbios_name_handler,
        '139': netbios_sesh_handler,
        '161,162,10161,10162': snmp_handler,
        '389,636': ldap_handler,
        '750': kerbv4_ticket_handler,
        '751': kerbv4_admin_handler,
        '1030,1032,1033,1038': windomain_handler,
        '1748,1754,1808,1809': oracle_agent_handler,
        '2049': nfs_handler,
        '3268,3269': globalcat_ldap_handler,
        '4445': upnotifyp_handler,
        '4555': rsip_handler,
        '5357': wsdapi_handler,
        '5722': dfsr_handler,
        '47001': wrms_handler
    }


def main():
    """
    Loads the config file, depending on config file settings, either runs ping scan to identify
    hosts or already has target host in config file, and launches the scan process on target hosts
    based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_list = []

    # Compile program regex and return as object #
    re_obj = RegexHandler()

    # If potential yaml config file passed into to program #
    if len(sys.argv) > 1:
        # Format passed in argument as path #
        config_path = cwd / 'Configs' / sys.argv[1]

        # If the passed in configuration file does not exist or is not a yaml file #
        if not config_path.exists() or not str(config_path).endswith('yml'):
            # Prompt user for yaml config file #
            config_path = config_input(cwd)

    # If no args were passed in #
    else:
        # Prompt user for yaml config file #
        config_path = config_input(cwd)

    # Load the YAML configuration file #
    config_data = file_handler(config_path, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue if they are proper ip addresses #
        [hosts.put(host) for host in config_obj.hosts if re.search(re_obj.re_ip, host)]

    # If CIDR network range is specified #
    elif config_obj.cidr != 'null':
        # If the provided cidr network in yaml is not properly formatted #
        if not re.search(re_obj.re_cidr, config_obj.cidr):
            print_err('Improper cidr network formatting in yaml config file')
            sys.exit(2)

        # Format ping output path #
        ping_path = cwd / 'ping_scan_out.txt'
        # Run ping scan on target CIDR #
        system_cmd(['nmap', '-vv', '-sn', '-n', config_obj.cidr], None, None, log_obj,
                   out_file=ping_path)
        # Read the output ping data saved to disk #
        ping_data = file_handler(ping_path, 'r')

        # Iterate through ping data line by line #
        for line in ping_data.split('\n'):
            # If the current line does not indicate failure #
            if not re.search(re_obj.re_ping_fail, line):
                # Attempt to match IP in line #
                ip_match = re.search(re_obj.re_ip, line)
                # If an IP matched in line #
                if ip_match:
                    # Put the matched IP address in hosts queue #
                    hosts.put(ip_match.group(0))

    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    # Initialize scan service function class #
    scan_obj = ScanClass()

    while True:
        # Iterate through process list #
        for proc in proc_list:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from process list #
                proc_list.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not proc_list:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, out_dir, config_obj,
                                                         scan_obj, log_queue))
            # Start process and put in process list #
            process.start()
            proc_list.append(process)
            num_cpu -= 1


def log_handler(logger_queue: Queue):
    """
    Logging thread that handles multiprocessing logging through the dedicated queue.

    :param logger_queue:  The logging queue used to pass messages to logging thread.
    :return:  Nothing
    """
    # Get the app logger #
    logger = logging.getLogger('App')
    while True:
        # Get log message from queue and log to file #
        log_message = logger_queue.get()
        # If there is a log message, log it #
        if log_message:
            logger.handle(log_message)


if __name__ == '__main__':
    # Get the current working directory #
    cwd = Path.cwd()
    # Format the output directory #
    out_dir = cwd / 'Output'
    # Create the output dir #
    out_dir.mkdir(parents=True, exist_ok=True)

    # Format path to log file #
    log_path = cwd / 'pentester_toolchain.log'
    # Set the log file name #
    logging.basicConfig(filename=log_path, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    log_queue = Queue()
    # Get the logger instance #
    log_obj = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    log_obj.addHandler(QueueHandler(log_queue))

    # Start background logging thread #
    log_thread = threading.Thread(target=log_handler, args=(log_queue,), daemon=True)
    log_thread.start()

    RET = 0
    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        log_obj.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    # Print and log total execution time #
    print(f'\n[!] Execution time: {exec_time}')
    log_obj.info('Execution time: %s\n\n', exec_time)
    # Sleep second to ensure logging thread logs info before exit #
    time.sleep(1)

    sys.exit(RET)
