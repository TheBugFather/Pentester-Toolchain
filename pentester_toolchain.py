""" Built-in modules """
import concurrent.futures
import logging
import re
import sys
import threading
import time
from concurrent.futures import BrokenExecutor, ThreadPoolExecutor
from multiprocessing import cpu_count, Process
from subprocess import check_output
from pathlib import Path
from queue import Queue
# External modules #
import ipaddress
# Custom Modules #
from Modules.utils import ConfigClass, config_input, file_handler, print_err, RegexHandler, \
                          ScanClass


def scan_process(target_ip: str, regex_obj: object, base_path: Path, configs_obj: object,
                 logger_queue: Queue):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param base_path:  Path to the base directory for the project output.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :param logger_queue:  The queue used for handling inter-process logging.
    :return:  Nothing
    """
    # Initialize scan service function class #
    scanner = ScanClass()
    # Get logging instance #
    logger = logging.getLogger('App')

    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        # TODO add in nmap scan
        file_path = cwd / 'nmapSampleOutputs' / 'blueprint_nmapOut.txt'
        # Read the nmap scan output #
        scan_data = file_handler(file_path, 'r')

        # Set error code for if not properly referenced in loop #
        scan_port = '-1'
        # Run regex operations on port scan output to find open ports #
        re_searches = regex_obj.scan_parse(scan_data)

        # Iterate through the regex result from port scan #
        for key, value in re_searches.items():
            # If the regex pattern matched #
            if value:
                # Split any variations of single or comma split ports #
                port_list = key.split(',')

                # Iterate through port list #
                for port in port_list:
                    # If current port found in match #
                    if port in value:
                        scan_port = port

                try:
                    # Execute service handler function #
                    scanner.func_dict[key](target_ip, base_path, int(scan_port), configs_obj,
                                           logger_queue)

                # If a key is passed in that does not exist #
                except (KeyError, ValueError) as exec_err:
                    # Log error and exit #
                    logger.error('Attempting to access non-existent key in ScanClass func_dict or '
                                 'error converting port to int: %s\n\n', exec_err)
                    sys.exit(5)

    # If ports already were identified on target #
    else:
        # Iterate through port list from yaml config #
        for port in configs_obj.ports:
            # Convert integer port to string #
            str_port = str(port)

            # Iterate through service dict items #
            for key, value in scanner.func_dict.items():
                # If the port is in the current key #
                if str_port in key:
                    try:
                        # Execute service handler function #
                        scanner.func_dict[key](target_ip, base_path, port, configs_obj,
                                               logger_queue)

                    # If a key is passed in that does not exist #
                    except KeyError as exec_err:
                        logger.error('Attempting to access non-existent key in ScanClass func_dict:'
                                     ' %s\n\n', exec_err)
                        sys.exit(5)


def ping_handler(ping_ip: str) -> bytes:
    # Execute ping with current ip in cidr and return results #
    return check_output(['ping', '-c', '1', ping_ip])


def ping_executor(ip_queue: Queue, config: object):
    # Get the app logger #
    logger = logging.getLogger('App')

    try:
        # Establish thread pool executor for ping scan #
        with ThreadPoolExecutor(max_workers=config.ping_threads) as executor:
            # Set up futures with each ip target in cidr range #
            future_to_ping = {executor.submit(ping_handler, str(ip)): ip for ip in
                              ipaddress.IPv4Network(config.cidr)}
            # Iterate through futures and get the results #
            for future in concurrent.futures.as_completed(future_to_ping):
                # Get result data from ping command #
                data = future.result()

                # If TTL in results meaning successful #
                if b'TTL' in data:
                    # Get the ip for current future #
                    ip = future_to_ping[future]
                    # Add the ip to the ip queue #
                    ip_queue.put(ip)

    # If there is an error with ThreadPoolExecutor #
    except BrokenExecutor as exec_err:
        # Print error, log, and exit #
        print_err(f'Error occurred with thread pool executor during ping scan: {exec_err}')
        logger.error('Error occurred with thread pool executor during ping scan: %s\n\n', exec_err)
        sys.exit(3)

    return ip_queue


def main():
    """
    Loads the config file, runs ping scan to get hosts if subnet scan specified, and launches the
    scan process on target hosts based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_list = []

    # Compile program regex and return as object #
    re_obj = RegexHandler()

    # If potential yaml config file passed into to program #
    if len(sys.argv) > 1:
        # Format passed in argument as path #
        config_path = cwd / 'Configs' / sys.argv[1]

        # If the passed in configuration file does not exist or is not a yaml file #
        if not config_path.exists() or not str(config_path).endswith('yml'):
            # Prompt user for yaml config file #
            config_path = config_input(cwd)

    # If no args were passed in #
    else:
        # Prompt user for yaml config file #
        config_path = config_input(cwd)

    # Load the YAML configuration file #
    config_data = file_handler(config_path, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue if they are proper ip addresses #
        [hosts.put(host) for host in config_obj.hosts if re.search(re_obj.re_ip, host)]

    # If CIDR network range is specified #
    elif config_obj.cidr:
        # If the provided cidr network in yaml is not properly formatted #
        if not re.search(re_obj.re_cidr, config_obj.cidr):
            print_err('Improper cidr network formatting in yaml config file')
            sys.exit(2)

        # Run ping scan of target hosts #
        hosts = ping_executor(hosts, config_obj)

    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    while True:
        # Iterate through join list #
        for proc in proc_list:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from join list #
                proc_list.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not proc_list:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, out_dir, config_obj,
                                                         log_queue))
            # Start process and put in process queue #
            process.start()
            proc_list.append(process)
            num_cpu -= 1


def log_handler(logger_queue: Queue):
    # Get the logger instance #
    logger = logging.getLogger('App')

    while True:
        # Get log message from queue and log to file #
        log_message = logger_queue.get()
        logger.handle(log_message)


if __name__ == '__main__':
    RET = 0
    log_queue = Queue()

    # Get the current working directory #
    cwd = Path.cwd()
    # Format the output directory #
    out_dir = cwd / 'Output'

    # If the output dir does not exist #
    if not out_dir.exists():
        # Create the output dir #
        out_dir.mkdir(parents=True)

    # Format path to log file #
    log_path = cwd / 'pentester_toolchain.log'

    # Set the log file name #
    logging.basicConfig(filename=log_path, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    # Get the logger instance #
    log_obj = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    log_obj.addHandler(log_queue)

    # Start background logging thread #
    log_thread = threading.Thread(target=log_handler, args=(log_queue,), daemon=True)
    log_thread.start()

    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        log_obj.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    # Print and log total execution time #
    print(f'\n[!] Execution time: {exec_time}')
    log_obj.info('Execution time: %s\n\n', exec_time)
    # Sleep second to ensure logging thread logs info before exit #
    time.sleep(1)

    sys.exit(RET)


