""" Built-in modules """
import logging
import re
import sys
import threading
import time
from concurrent.futures import as_completed, BrokenExecutor, ThreadPoolExecutor
from logging.handlers import QueueHandler
from multiprocessing import cpu_count, Process
from subprocess import check_output
from pathlib import Path
from queue import Queue
# External modules #
import ipaddress
# Custom Modules #
from Modules.utils import cmd_parser, ConfigClass, config_input, file_handler, print_err, \
                          RegexHandler, ScanClass, system_cmd


def scan_process(target_ip: str, regex_obj: object, base_path: Path, configs_obj: object,
                 scanner: object, logger_queue: Queue):
    """
    Facilitate various scans and pentesting tools, saving output results, and chaining tool
    executions based on regular expression parsing on scan output.

    :param target_ip:  The IP address of the targ to be scanned.
    :param regex_obj:  The compiled regex instance.
    :param base_path:  Path to the base directory for the project output.
    :param configs_obj:  The program configuration instance from loaded yaml file.
    :param scanner:  The program scan process service function class.
    :param logger_queue:  The queue used for handling inter-process logging.
    :return:  Nothing
    """
    # Get logging instance #
    logger = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    logger.addHandler(QueueHandler(logger_queue))
    # Set file paths for target directory and nmap scans #
    host_path = base_path / target_ip
    tcp_path = host_path / 'TCP_Handlers'
    udp_path = host_path / 'UDP_Handlers'
    tcp_udp_path = host_path / 'TCP_UDP_Handlers'
    scan_dirs = (host_path, tcp_path, udp_path, tcp_udp_path)

    # Iterate through program directory paths #
    for path in scan_dirs:
        # Create the dir #
        path.mkdir(parents=True, exist_ok=True)

    # If there were no ports specified in config instance #
    if not configs_obj.ports:
        # Set the nmap paths #
        nmap_path = host_path / 'Nmap'
        nmap_start = nmap_path / 'nmap_init.txt'
        nmap_end = nmap_path / 'nmap_full.txt'
        # Create the nmap directory #
        nmap_path.mkdir(parents=True, exist_ok=True)

        # Get the initial nmap port scan syntax from config class #
        yaml_cmd = configs_obj.nmap_init
        # Check and parse the yaml command
        cmd = cmd_parser(yaml_cmd, regex_obj, target_ip)

        # Run the initial nmap scan to enumerate
        # common service ports of interest #
        system_cmd(cmd.split(), None, None, logger, out_file=nmap_start)
        # Read the nmap scan output #
        scan_data = file_handler(nmap_start, 'r')

        # Set error code for if not properly referenced in loop #
        scan_port = '-1'
        # Run regex operations on port scan output to find open ports #
        re_searches = regex_obj.scan_parse(scan_data)

        # Iterate through the regex result from port scan #
        for key, value in re_searches.items():
            # If the regex pattern matched #
            if value:
                # Split any variations of single or comma split ports #
                port_list = key.split(',')

                # Iterate through port list #
                for port in port_list:
                    # If current port found in match #
                    if port in value:
                        # Assign as scan port & exit loop #
                        scan_port = port
                        break

                try:
                    # Execute service handler function #
                    scanner.service_handler[key](target_ip, scan_dirs, int(scan_port), configs_obj,
                                                 regex_obj, logger)

                # If a key is passed in that does not exist #
                except (KeyError, ValueError) as exec_err:
                    # Log error and exit #
                    logger.error('Attempting to access non-existent key in ScanClass func_dict or '
                                 'error converting port to int: %s\n\n', exec_err)
                    sys.exit(5)

        # Get the initial nmap port scan syntax from config class #
        yaml_cmd = configs_obj.nmap_final
        # Check and parse the yaml command
        cmd = cmd_parser(yaml_cmd, regex_obj, target_ip)

        # Run final nmap scan on all uncommon ports #
        system_cmd(cmd.split(), None, None, logger, out_file=nmap_end)

    # If ports already were identified on target #
    else:
        # Iterate through port list from yaml config #
        for port in configs_obj.ports:
            # Ensure port is string format #
            str_port = str(port)
            # If the converted string port is not a base10 decimal #
            if not str_port.isdigit():
                # Log error and move to next port #
                logger.error('Port \"%s\" in yaml file is not of base10 decimal format\n\n',
                             str_port)
                continue

            # Iterate through service dict items #
            for key, value in scanner.service_handler.items():
                # If the port is in the current key #
                if str_port in key:
                    try:
                        # Execute service handler function #
                        scanner.service_handler[key](target_ip, scan_dirs, port, configs_obj,
                                                     regex_obj, logger)

                    # If a key is passed in that does not exist #
                    except KeyError as exec_err:
                        logger.error('Attempting to access non-existent key in ScanClass func_dict:'
                                     ' %s\n\n', exec_err)
                        sys.exit(5)


def ping_handler(ping_ip: str) -> bytes:
    # Execute ping with current ip in cidr and return results #
    return check_output(['ping', '-c', '1', ping_ip])


def ping_executor(ip_queue: Queue, config: object, logger: logging.Logger):
    try:
        # Establish thread pool executor for ping scan #
        with ThreadPoolExecutor(max_workers=config.ping_threads) as executor:
            # Set up futures with each ip target in cidr range #
            future_to_ping = {executor.submit(ping_handler, str(ip)): ip for ip in
                              ipaddress.IPv4Network(config.cidr)}
            # Iterate through futures and get the results #
            for future in as_completed(future_to_ping):
                # Get result data from ping command #
                data = future.result()

                # If TTL in results meaning successful #
                if b'TTL' in data:
                    # Get the ip for current future #
                    ip = future_to_ping[future]
                    # Add the ip to the ip queue #
                    ip_queue.put(ip)

    # If there is an error with ThreadPoolExecutor #
    except BrokenExecutor as exec_err:
        # Print error, log, and exit #
        print_err(f'Error occurred with thread pool executor during ping scan: {exec_err}')
        logger.error('Error occurred with thread pool executor during ping scan: %s\n\n', exec_err)
        sys.exit(3)

    return ip_queue


def main():
    """
    Loads the config file, runs ping scan to get hosts if subnet scan specified, and launches the
    scan process on target hosts based on the available number of cpu's.

    :return:  Nothing
    """
    hosts = Queue()
    proc_list = []

    # Compile program regex and return as object #
    re_obj = RegexHandler()

    # If potential yaml config file passed into to program #
    if len(sys.argv) > 1:
        # Format passed in argument as path #
        config_path = cwd / 'Configs' / sys.argv[1]

        # If the passed in configuration file does not exist or is not a yaml file #
        if not config_path.exists() or not str(config_path).endswith('yml'):
            # Prompt user for yaml config file #
            config_path = config_input(cwd)

    # If no args were passed in #
    else:
        # Prompt user for yaml config file #
        config_path = config_input(cwd)

    # Load the YAML configuration file #
    config_data = file_handler(config_path, 'r', yaml=True)
    # Parse config data into class #
    config_obj = ConfigClass(config_data)

    # If specific target hosts are already specified #
    if config_obj.hosts:
        # Iterate through hosts and put in host queue if they are proper ip addresses #
        [hosts.put(host) for host in config_obj.hosts if re.search(re_obj.re_ip, host)]

    # If CIDR network range is specified #
    elif config_obj.cidr != 'null':
        # If the provided cidr network in yaml is not properly formatted #
        if not re.search(re_obj.re_cidr, config_obj.cidr):
            print_err('Improper cidr network formatting in yaml config file')
            sys.exit(2)

        # Run ping scan of target hosts #
        hosts = ping_executor(hosts, config_obj, log_obj)

    # If neither were specified causing error #
    else:
        print_err('Improper configuration file settings .. set either hosts or cidr range to ping')
        sys.exit(2)

    # Initialize scan service function class #
    scan_obj = ScanClass()

    while True:
        # Iterate through process list #
        for proc in proc_list:
            # If the process is no longer running #
            if not proc.is_alive():
                # Remove the process from process list #
                proc_list.remove(proc)

        # If all hosts have been scanned #
        if hosts.empty() and not proc_list:
            break

        # Get the number of available cpu #
        num_cpu = cpu_count()

        # While there are cores available and hosts to scan #
        while num_cpu > config_obj.min_cores and not hosts.empty():
            # Create scan process with next available host #
            process = Process(target=scan_process, args=(hosts.get(), re_obj, out_dir, config_obj,
                                                         scan_obj, log_queue))
            # Start process and put in process list #
            process.start()
            proc_list.append(process)
            num_cpu -= 1


def log_handler(logger: logging.Logger, logger_queue: Queue):
    while True:
        # Get log message from queue and log to file #
        log_message = logger_queue.get()
        # If there is a log message, log it #
        if log_message:
            logger.handle(log_message)


if __name__ == '__main__':
    # Get the current working directory #
    cwd = Path.cwd()
    # Format the output directory #
    out_dir = cwd / 'Output'
    # Create the output dir #
    out_dir.mkdir(parents=True, exist_ok=True)

    # Format path to log file #
    log_path = cwd / 'pentester_toolchain.log'
    # Set the log file name #
    logging.basicConfig(filename=log_path, level=logging.DEBUG,
                        format='%(asctime)s line%(lineno)d::%(funcName)s[%(levelname)s]>>'
                               ' %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    log_queue = Queue()
    # Get the logger instance #
    log_obj = logging.getLogger('App')
    # Add logger handler that uses shared queue #
    log_obj.addHandler(QueueHandler(log_queue))

    # Start background logging thread #
    log_thread = threading.Thread(target=log_handler, args=(log_obj, log_queue), daemon=True)
    log_thread.start()

    RET = 0
    # Record the start time #
    start_time = time.perf_counter()

    try:
        main()

    # If unknown exception occurs #
    except Exception as ex:
        print_err(f'Unknown exception occurred: {ex}')
        log_obj.exception('Unknown exception occurred: %s\n\n', ex)
        RET = 1

    # Record the finish time #
    exec_time = time.perf_counter() - start_time

    # Print and log total execution time #
    print(f'\n[!] Execution time: {exec_time}')
    log_obj.info('Execution time: %s\n\n', exec_time)
    # Sleep second to ensure logging thread logs info before exit #
    time.sleep(1)

    sys.exit(RET)


