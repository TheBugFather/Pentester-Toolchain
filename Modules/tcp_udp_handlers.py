""" Custom modules """
from Modules.utils import cmd_parser, file_handler, system_cmd


def wins_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the wins output file path #
    wins_path = paths[3] / 'wins_out.txt'

    # Iterate through wins commands from yaml file #
    for command in config.wins:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(wins_path, 'a', log_tuple[1], data=data)


def dns_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the dns output file path #
    dns_path = paths[3] / 'dns_out.txt'

    # Iterate through dns commands from yaml file #
    for command in config.dns:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(dns_path, 'a', log_tuple[1], data=data)


def kerbv5_ticket_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                          log_tuple: tuple):
    # Set the kerberos v5 ticket output file path #
    kerbv5_ticket_path = paths[3] / 'kerbv5_ticket_out.txt'

    # Iterate through kerberos v5 ticket commands from yaml file #
    for command in config.kerberos_v5_ticket:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(kerbv5_ticket_path, 'a', log_tuple[1], data=data)


def rpc_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the rpc output file path #
    rpc_path = paths[3] / 'rpc_out.txt'

    # Iterate through rpc commands from yaml file #
    for command in config.rpc:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(rpc_path, 'a', log_tuple[1], data=data)


def ntp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the ntp output file path #
    ntp_path = paths[3] / 'ntp_out.txt'

    # Iterate through ntp commands from yaml file #
    for command in config.ntp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(ntp_path, 'a', log_tuple[1], data=data)


def msrpc_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                  log_tuple: tuple):
    # Set the msrpc output file path #
    msrpc_path = paths[3] / 'msrpc_out.txt'

    # Iterate through msrpc commands from yaml file #
    for command in config.msrpc:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(msrpc_path, 'a', log_tuple[1], data=data)


def netbios_name_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                         log_tuple: tuple):
    # Set the netbios name output file path #
    netbios_name_path = paths[3] /'netbios_name_out.txt'

    # Iterate through netbios name commands from yaml file #
    for command in config.netbios_name:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(netbios_name_path, 'a', log_tuple[1], data=data)


def netbios_sesh_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                         log_tuple: tuple):
    # Set the netbios session output file name #
    netbios_sesh_path = paths[3] / 'netbios_sesh_out.txt'

    # Iterate through netbios session commands from yaml file #
    for command in config.netbios_sesh:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(netbios_sesh_path, 'a', log_tuple[1], data=data)


def snmp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the snmp output file path #
    snmp_path = paths[3] / 'snmp_out.txt'

    # Iterate through snmp commands from yaml file #
    for command in config.snmp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(snmp_path, 'a', log_tuple[1], data=data)


def ldap_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the ldap output file path #
    ldap_path = paths[3] / 'ldap_out.txt'

    # Iterate through ldap commands from yaml file #
    for command in config.ldap:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(ldap_path, 'a', log_tuple[1], data=data)


def kerbv4_ticket_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                          log_tuple: tuple):
    # Set the kerberos v4 ticket output file path #
    kerbv4_ticket_path = paths[3] / 'kerbv4_ticket_out.txt'

    # Iterate through kerberos v5 ticket commands from yaml file #
    for command in config.kerberos_v4_ticket:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(kerbv4_ticket_path, 'a', log_tuple[1], data=data)


def kerbv4_admin_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                         log_tuple: tuple):
    # Set the kerberos v4 admin output file path #
    kerbv4_admin_path = paths[3] / 'kerbv4_admin_out.txt'

    # Iterate through kerberos v4 admin commands from yaml file #
    for command in config.kerberos_v4_admin:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(kerbv4_admin_path, 'a', log_tuple[1], data=data)


def windomain_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                      log_tuple: tuple):
    # Set the winddomain output file path #
    windomain_path = paths[3] / 'windomain_out.txt'

    # Iterate through windows domain commands from yaml file #
    for command in config.windomain_indicator:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(windomain_path, 'a', log_tuple[1], data=data)


def oracle_agent_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                         log_tuple: tuple):
    # Set the oracle agent output file path #
    oracle_agent_path = paths[3] / 'oracle_agent_out.txt'

    # Iterate through oracle agent commands from yaml file #
    for command in config.oracle_agent:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(oracle_agent_path, 'a', log_tuple[1], data=data)


def nfs_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the nfs output file path #
    nfs_path = paths[3] / 'nfs_out.txt'

    # Iterate through nfs commands from yaml file #
    for command in config.nfs:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(nfs_path, 'a', log_tuple[1], data=data)


def globalcat_ldap_handler(ip_addr: str, paths: tuple, port_num: int, config: object,
                           re_obj: object, log_tuple: tuple):
    # Set the globalcat ldap output file path #
    globalcat_ldap_path = paths[3] / 'globalcat_ldap_out.txt'

    # Iterate through globalcat ldap commands from yaml file #
    for command in config.globalcat_ldap:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(globalcat_ldap_path, 'a', log_tuple[1], data=data)


def upnotifyp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                      log_tuple: tuple):
    # Set the upnotifyp file path #
    upnotifyp_path = paths[3] / 'upnotifyp_out.txt'

    # Iterate through upnotifyp commands from yaml file #
    for command in config.upnotifyp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(upnotifyp_path, 'a', log_tuple[1], data=data)


def rsip_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the rsip output file path #
    rsip_path = paths[3] / 'rsip_out.txt'

    # Iterate through rsip commands from yaml file #
    for command in config.rsip:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(rsip_path, 'a', log_tuple[1], data=data)


def wsdapi_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                   log_tuple: tuple):
    # Set the wsdapi output file path #
    wsdapi_path = paths[3] / 'wsdapi_out.txt'

    # Iterate through wsdapi commands from yaml file #
    for command in config.wsdapi:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(wsdapi_path, 'a', log_tuple[1], data=data)


def dfsr_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the dfsr output file path #
    dfsr_path = paths[3] / 'dfsr_out.txt'

    # Iterate through dfsr commands from yaml file #
    for command in config.dfsr:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(dfsr_path, 'a', log_tuple[1], data=data)


def wrms_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the wrms output file path #
    wrms_path = paths[3] / 'wrms_out.txt'

    # Iterate through wrms commands from yaml file #
    for command in config.wrms:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            cmd = cmd_parser(command, re_obj, ip_addr, port_num)
            cmd_list = cmd.split()
        # If command has no args to parse #
        else:
            # Split args into list #
            cmd_list = command.split()

        # Execute system command #
        output = system_cmd(cmd_list, None, log_tuple[1])

        # If the command return data #
        if output:
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n'
            # Write the output with command title to service file #
            file_handler(wrms_path, 'a', log_tuple[1], data=data)
