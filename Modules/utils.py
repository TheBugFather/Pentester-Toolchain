""" Built-in modules """
import errno
import logging
import os
import re
import sys
from multiprocessing import Lock
from pathlib import Path
from subprocess import Popen, PIPE, TimeoutExpired
# External modules #
from yaml import safe_load


# Global variables #
STDERR_LOCK = Lock()


def cmd_parser(yaml_syntax: str, reg_obj: object, *args) -> str:
    """
    Take input command parsed from yaml file, and parses in any delimiters in the command with
    passed in variable length parameters.

    :param yaml_syntax:  The command from yaml file to be delimiter parsed.
    :param reg_obj:  The compiled regex pattern object.
    :param args:  The passed in variable-length arguments.
    :return:  The parsed command to be executed.
    """
    parsed_cmd = ''

    # Iterate through passed in variable length args #
    for arg in args:
        # Ensure the arg is string format #
        arg = str(arg)

        # If ip delimiter is in passed in yaml command and arg matches ip or hostname regex #
        if '<host>' in yaml_syntax and (re.search(reg_obj.re_ip, arg) or
                                        re.search(reg_obj.re_hostname, arg)):
            # If the command has yet to be parsed #
            if not parsed_cmd:
                # Replace the IP delimiter with actual target ip #
                parsed_cmd = yaml_syntax.replace('<host>', arg)
            # If the command has already had and a delimiter parsed #
            else:
                # Replace the IP delimiter with actual target ip #
                parsed_cmd = parsed_cmd.replace('<host>', arg)

            continue

        try:
            # Attempt to convert arg to string #
            int_port = int(arg)

            # If port delimiter is in passed in yaml command and arg matches port regex #
            if '<port>' in yaml_syntax and 20 <= int_port <= 47001:
                # If the command has yet to be parsed #
                if not parsed_cmd:
                    # Replace the port delimiter with actual target port #
                    parsed_cmd = yaml_syntax.replace('<port>', arg)
                # If the command has already had and a delimiter parsed #
                else:
                    # Replace the port delimiter with actual target port #
                    parsed_cmd = parsed_cmd.replace('<port>', arg)

                continue

        # If the str arg is not base10 decimal #
        except ValueError:
            pass

        # If path delimiter is in passed in yaml command and arg matches path regex #
        if '<path>' in yaml_syntax and re.search(reg_obj.re_path, arg):
            # If the command has yet to be parsed #
            if not parsed_cmd:
                # Replace the path delimiter with actual target path #
                parsed_cmd = yaml_syntax.replace('<path>', arg)
            # If the command has already had a delimiter parsed #
            else:
                # Replace the path delimiter with the actual path #
                parsed_cmd = parsed_cmd.replace('<path>', arg)

            continue

        # If path delimiter is in passed in yaml command and arg matches protocol regex #
        if '<proto>' in yaml_syntax and re.search(reg_obj.re_proto, arg):
            # If the command has yet to be parsed #
            if not parsed_cmd:
                # Replace the path delimiter with actual target path #
                parsed_cmd = yaml_syntax.replace('<proto>', arg)
            # If the command has already had a delimiter parsed #
            else:
                # Replace the path delimiter with the actual path #
                parsed_cmd = parsed_cmd.replace('<proto>', arg)

    return parsed_cmd


class ConfigClass:
    """
    Class to store yaml file configurations that are referenced throughout operations.

    :param cwd:  The path the the current working directory.
    :param yaml_data:  Dict data from yaml file to be parsed into config class.
    """
    def __init__(self, cwd: Path, yaml_data: dict):
        # Program initialization variables #
        self.min_cores = yaml_data['init']['min_cores']
        self.hosts = yaml_data['init']['hosts']
        self.cidr = yaml_data['init']['cidr']
        self.ports = yaml_data['init']['ports']
        self.nmap_init = yaml_data['init']['nmap_init']
        self.nmap_final = yaml_data['init']['nmap_final']
        self.markdown = yaml_data['init']['generate_markdown']
        self.delimiters = ['<host', '<port>', '<proto>']
        self.shell = os.environ.get('SHELL')

        # Get partial path from yaml config data #
        __custom_path = cwd / Path(yaml_data['init']['custom_program_path'])
        # If the custom program path exists #
        if __custom_path.exists():
            # If the custom has program files in it #
            if [str(file) for file in __custom_path.iterdir()]:
                self.custom_program_path = str(__custom_path)
            # If there are no custom programs in dir #
            else:
                self.custom_program_path = False
        # If the custom program path does not exist or is empty #
        else:
            # Create the missing directory #
            __custom_path.mkdir(parents=True)
            self.custom_program_path = False

        # TCP based port commands #
        self.ftp = yaml_data['ftp']['commands']
        self.ftp_custom = yaml_data['ftp']['custom_commands']
        self.ssh = yaml_data['ssh']['commands']
        self.ssh_custom = yaml_data['ssh']['custom_commands']
        self.telnet = yaml_data['telnet']['commands']
        self.telnet_custom = yaml_data['telnet']['custom_commands']
        self.smtp = yaml_data['smtp']['commands']
        self.smtp_custom = yaml_data['smtp']['custom_commands']
        self.whois = yaml_data['whois']['commands']
        self.whois_custom = yaml_data['whois']['custom_commands']
        self.finger = yaml_data['finger']['commands']
        self.finger_custom = yaml_data['finger']['custom_commands']
        self.web = yaml_data['web']['commands']
        self.web_custom = yaml_data['web']['custom_commands']
        self.pop3 = yaml_data['pop3']['commands']
        self.pop3_custom = yaml_data['pop3']['custom_commands']
        self.ident = yaml_data['ident']['commands']
        self.ident_custom = yaml_data['ident']['custom_commands']
        self.nntp = yaml_data['nntp']['commands']
        self.nntp_custom = yaml_data['nntp']['custom_commands']
        self.imap = yaml_data['imap']['commands']
        self.imap_custom = yaml_data['imap']['custom_commands']
        self.smux = yaml_data['smux']['commands']
        self.smux_custom = yaml_data['smux']['custom_commands']
        self.checkpoint_firewall = yaml_data['checkpoint_firewall']['commands']
        self.checkpoint_firewall_custom = yaml_data['checkpoint_firewall']['custom_commands']
        self.smb = yaml_data['smb']['commands']
        self.smb_custom = yaml_data['smb']['custom_commands']
        self.modbus = yaml_data['modbus']['commands']
        self.modbus_custom = yaml_data['modbus']['custom_commands']
        self.rexec = yaml_data['rexec']['commands']
        self.rexec_custom = yaml_data['rexec']['custom_commands']
        self.rlogin = yaml_data['rlogin']['commands']
        self.rlogin_custom = yaml_data['rlogin']['custom_commands']
        self.rsh = yaml_data['rsh']['commands']
        self.rsh_custom = yaml_data['rsh']['custom_commands']
        self.lpd = yaml_data['lpd']['commands']
        self.lpd_custom = yaml_data['lpd']['custom_commands']
        self.apple_filing = yaml_data['apple_filing']['commands']
        self.apple_filing_custom = yaml_data['apple_filing']['custom_commands']
        self.rtsp = yaml_data['rtsp']['commands']
        self.rtsp_custom = yaml_data['rtsp']['custom_commands']
        self.cups = yaml_data['cups']['commands']
        self.cups_custom = yaml_data['cups']['custom_commands']
        self.kerberos_v5_admin_tcp = yaml_data['kerberos_v5_admin_tcp']['commands']
        self.kerberos_v5_admin_tcp_custom = yaml_data['kerberos_v5_admin_tcp']['custom_commands']
        self.kerberos_v4_passwd_tcp = yaml_data['kerberos_v4_passwd_tcp']['commands']
        self.kerberos_v4_passwd_tcp_custom = yaml_data['kerberos_v4_passwd_tcp']['custom_commands']
        self.rsync = yaml_data['rsync']['commands']
        self.rsync_custom = yaml_data['rsync']['custom_commands']
        self.iis = yaml_data['iis']['commands']
        self.iis_custom = yaml_data['iis']['custom_commands']
        self.mssql = yaml_data['mssql']['commands']
        self.mssql_custom = yaml_data['mssql']['custom_commands']
        self.oracle_db = yaml_data['oracle_db']['commands']
        self.oracle_db_custom = yaml_data['oracle_db']['custom_commands']
        self.oracle_xml_db = yaml_data['oracle_xml_db']['commands']
        self.oracle_xml_db_custom = yaml_data['oracle_xml_db']['custom_commands']
        self.sql = yaml_data['sql']['commands']
        self.sql_custom = yaml_data['sql']['custom_commands']
        self.oracle_web = yaml_data['oracle_web']['commands']
        self.oracle_web_custom = yaml_data['oracle_web']['custom_commands']
        self.rdp = yaml_data['rdp']['commands']
        self.rdp_custom = yaml_data['rdp']['custom_commands']
        self.adb = yaml_data['adb']['commands']
        self.adb_custom = yaml_data['adb']['custom_commands']
        self.vnc = yaml_data['vnc']['commands']
        self.vnc_custom = yaml_data['vnc']['custom_commands']
        self.winrm = yaml_data['winrm']['commands']
        self.winrm_custom = yaml_data['winrm']['custom_commands']
        self.irc_tcp = yaml_data['irc_tcp']['commands']
        self.irc_tcp_custom = yaml_data['irc_tcp']['custom_commands']
        self.adac = yaml_data['adac']['commands']
        self.adac_custom = yaml_data['adac']['custom_commands']

        # UDP based port commands #
        self.dhcp = yaml_data['dhcp']['commands']
        self.dhcp_custom = yaml_data['dhcp']['custom_commands']
        self.tftp = yaml_data['tftp']['commands']
        self.tftp_custom = yaml_data['tftp']['custom_commands']
        self.kerberos_v5_passwd_udp = yaml_data['kerberos_v5_passwd_udp']['commands']
        self.kerberos_v5_passwd_udp_custom = yaml_data['kerberos_v5_passwd_udp']['custom_commands']
        self.ipsec_ike_vpn = yaml_data['ipsec_ike_vpn']['commands']
        self.ipsec_ike_vpn_custom = yaml_data['ipsec_ike_vpn']['custom_commands']
        self.kerberos_v5_ticket_udp = yaml_data['kerberos_v5_ticket_udp']['commands']
        self.kerberos_v5_ticket_udp_custom = yaml_data['kerberos_v5_ticket_udp']['custom_commands']
        self.mdns = yaml_data['mdns']['commands']
        self.mdns_custom = yaml_data['mdns']['custom_commands']

        # TCP/UDP based port commands #
        self.wins = yaml_data['wins']['commands']
        self.wins_custom = yaml_data['wins']['custom_commands']
        self.dns = yaml_data['dns']['commands']
        self.dns_custom = yaml_data['dns']['custom_commands']
        self.kerberos_v5_ticket = yaml_data['kerberos_v5_ticket']['commands']
        self.kerberos_v5_ticket_custom = yaml_data['kerberos_v5_ticket']['custom_commands']
        self.rpc = yaml_data['rpc']['commands']
        self.rpc_custom = yaml_data['rpc']['custom_commands']
        self.ntp = yaml_data['ntp']['commands']
        self.ntp_custom = yaml_data['ntp']['custom_commands']
        self.msrpc = yaml_data['msrpc']['commands']
        self.msrpc_custom = yaml_data['msrpc']['custom_commands']
        self.netbios_name = yaml_data['netbios_name']['commands']
        self.netbios_name_custom = yaml_data['netbios_name']['custom_commands']
        self.netbios_sesh = yaml_data['netbios_sesh']['commands']
        self.netbios_sesh_custom = yaml_data['netbios_sesh']['custom_commands']
        self.snmp = yaml_data['snmp']['commands']
        self.snmp_custom = yaml_data['snmp']['custom_commands']
        self.irc = yaml_data['irc']['commands']
        self.irc_custom = yaml_data['irc']['custom_commands']
        self.ldap = yaml_data['ldap']['commands']
        self.ldap_custom = yaml_data['ldap']['custom_commands']
        self.kerberos_v4_ticket = yaml_data['kerberos_v4_ticket']['commands']
        self.kerberos_v4_ticket_custom = yaml_data['kerberos_v4_ticket']['custom_commands']
        self.kerberos_v4_admin = yaml_data['kerberos_v4_admin']['commands']
        self.kerberos_v4_admin_custom = yaml_data['kerberos_v4_admin']['custom_commands']
        self.windomain_indicator = yaml_data['windomain_indicator']['commands']
        self.windomain_indicator_custom = yaml_data['windomain_indicator']['custom_commands']
        self.oracle_agent = yaml_data['oracle_agent']['commands']
        self.oracle_agent_custom = yaml_data['oracle_agent']['custom_commands']
        self.nfs = yaml_data['nfs']['commands']
        self.nfs_custom = yaml_data['nfs']['custom_commands']
        self.globalcat_ldap = yaml_data['globalcat_ldap']['commands']
        self.globalcat_ldap_custom = yaml_data['globalcat_ldap']['custom_commands']
        self.upnotifyp = yaml_data['upnotifyp']['commands']
        self.upnotifyp_custom = yaml_data['upnotifyp']['custom_commands']
        self.rsip = yaml_data['rsip']['commands']
        self.rsip_custom = yaml_data['rsip']['custom_commands']
        self.wsdapi = yaml_data['wsdapi']['commands']
        self.wsdapi_custom = yaml_data['wsdapi']['custom_commands']
        self.dfsr = yaml_data['dfsr']['commands']
        self.dfsr_custom = yaml_data['dfsr']['custom_commands']
        self.wrms = yaml_data['wrms']['commands']
        self.wrms_custom = yaml_data['wrms']['custom_commands']


def config_input(base_path: Path) -> Path:
    """
    Prompts user for yaml configuration to use for scan automation.

    :param base_path:  The base path to the current working directory.
    :return:  Validated configuration file path to be used for scans.
    """
    while True:
        # Gather user input to specify what config file to use #
        file_name = input('[+] Please enter the name of the config file to use or hit enter for '
                          'default config.yml file: ')

        # If the default file was selected (enter) #
        if not file_name:
            file_path = base_path / 'Configs' / 'config.yml'
        # For any input other than enter #
        else:
            # Format path with input config file name #
            file_path = base_path / 'Configs' / file_name

        # If the input file does not exist or is not a yaml config file #
        if not file_path.exists() or not str(file_path).endswith('yml'):
            # Print error and re-iterate #
            print_err('Input file path does not exist .. try again')
            continue

        return file_path


def error_query(err_path: str, err_mode: str, err_obj: object, logger: logging.Logger):
    """
    Looks up the errno message to get description, then prints and logs associated error, lastly
    exits.

    :param err_path:  The path to the file where error occurred.
    :param err_mode:  The file mode used during error.
    :param err_obj:  The error instance passed in from occurrence.
    :param logger:  The logging instance to handle associated errors.
    :return:  Nothing
    """
    # If file does not exist #
    if err_obj.errno == errno.ENOENT:
        print_err(f'{err_path} does not exist', is_locked=True)
        logger.log(logging.ERROR, '%s does not exist', err_path)
        sys.exit(6)

    # If the file does not have read/write access #
    elif err_obj.errno == errno.EPERM:
        print_err(f'{err_path} does not have permissions for {err_mode} file mode, if file exists '
                 'confirm it is closed', is_locked=True)
        logger.log(logging.ERROR, '%s does not have permissions for %s file mode',
                   err_path, err_mode)
        sys.exit(7)

    # File IO error occurred #
    elif err_obj.errno == errno.EIO:
        print_err(f'IO error occurred during {err_mode} mode on {err_path}', is_locked=True)
        logger.log(logging.ERROR, 'IO error occurred during %s mode on %s', err_mode, err_path)
        sys.exit(8)

    # If other unexpected file operation occurs #
    else:
        print_err(f'Unexpected file operation occurred accessing {err_path}: {err_obj.errno}',
                  is_locked=True)
        logger.log(logging.ERROR, 'Unexpected file operation occurred accessing %s: %s',
                   err_path, err_obj.errno)
        sys.exit(9)


def file_handler(file_path: Path, mode: str, logger: logging.Logger, data=None,
                 yaml=False) -> str | None:
    """
    Read/Write file operation handler for text and yaml file formats.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to performed on file.
    :param logger:  The logging instance to handle associated errors.
    :param data:  Kwarg data param for writing data to file.
    :param yaml:  Kwarg boolean operator to handle yaml configuration files.
    :return:  Read string data on read or None for write.
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                # If the file is text format #
                if not yaml:
                    # Return text data #
                    return file.read()
                # If the file is YAML format #
                else:
                    # Return Safe loaded YAML data #
                    return safe_load(file)

            # If file mode is write operation #
            else:
                # If there is no data to write #
                if not data:
                    # Print error, log, and exit #
                    print_err(f'Attempting to write to {file_path.name} with no data',
                              is_locked=True)
                    logger.log(logging.ERROR, 'Attempting to write to %s with no data',
                               file_path.name)
                    sys.exit(10)

                # If attempting to overwrite yaml config file #
                if yaml:
                    # Print error, log, and exit #
                    print_err('Attempted to write to YAML configuration file', is_locked=True)
                    logger.log(logging.ERROR, 'Attempted to write to YAML configuration file')
                    sys.exit(11)

                file.write(data)

            # Follows pylint return all or nothing rule #
            return None

    # If error occurs during file operation #
    except (IOError, OSError) as err:
        # Look up file error, log, and exit #
        error_query(str(file_path), mode, err, logger)


def logger_config() -> dict:
    """
    Retrieves the logging configuration in dict form.

    :return:  The populated logging configuration.
    """
    return {
        'version': 1,
        'formatters': {
            'detailed': {
                'class': 'logging.Formatter',
                'format': '%(asctime)s %(lineno)4d@%(filename)-24s%(processName)-12s'
                          '[%(levelname)s]>>  %(message)s',
                'datefmt': '%Y-%m-%d %H:%M:%S'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO'
            },
            'file': {
                'class': 'logging.FileHandler',
                'filename': 'pentester-toolchain.log',
                'formatter': 'detailed'
            },
            'scanfile': {
                'class': 'logging.FileHandler',
                'filename': 'pentester-toolchain-scan.log',
                'formatter': 'detailed'
            },
            'errors': {
                'class': 'logging.FileHandler',
                'filename': 'pentester-toolchain-errors.log',
                'level': 'ERROR',
                'formatter': 'detailed'
            }
        },
        'loggers': {
            'output': {
                'handlers': ['console']
            },
            'scan': {
                'handlers': ['scanfile', 'errors']
            }
        },
        'root': {
            'handlers': ['file', 'errors'],
            'level': 'DEBUG'
        }
    }


def markdown_formatter(output_dir: Path, logger: logging.Logger, regex_obj):
    """
    Crawls recursively through output dir and converts text output file into markdown copy.

    :param output_dir:  The path to the output directory.
    :param logger:  The logger instance
    :param regex_obj:  The compiled regex instance.
    :return:  Nothing
    """
    # Iterate through dirs and files recursively in Output dir #
    for dir_path, _, file_names in os.walk(output_dir):
        # Iterate through files in current directory #
        for file in file_names:
            # If the current file is text #
            if file.endswith('.txt'):
                # Set the current file path #
                file_path = Path(dir_path) / file
                # Read the data from the text file #
                text_data = file_handler(file_path, 'r', logger)
                markdown_data = ''

                # Iterate through read text data #
                for line in text_data.split('\n'):
                    # If line starts with title delimiter #
                    if line.startswith('>>'):
                        # Add line with parsed markdown title format #
                        markdown_data += f'{line.replace(">>", "##")}\n'
                        continue

                    # Search line with regex for asterisk based delimiter line #
                    line_search = re.search(regex_obj.re_md_line, line)
                    # If the current line is the asterisk delimiter line #
                    if line_search:
                        # Replace asterisk delimiter line with markdown line #
                        parsed_line = re.sub(regex_obj.re_md_line, line, '---')
                        # Parse in line with title as header with proper spacing #
                        markdown_data += f'\n{parsed_line}\n'
                        continue

                    markdown_data += f'{line}\n'

                # Format markdown output file path and write to file #
                markdown_path = Path(dir_path) / file.replace('.txt', '.md')
                file_handler(markdown_path, 'w', logger, data=markdown_data)


def print_err(msg: str, is_locked=False):
    """
    Displays the error message through stderr (standard error) with multiprocessing locking support.

    :param msg:  The error message to be displayed.
    :param is_locked:  Boolean kwarg to enabling print with mutex locking. Turned off by default.
    :return:  Nothing
    """
    # If the multiprocessing lock is not set #
    if not is_locked:
        print(f'* [ERROR] {msg} *', file=sys.stderr)
    # If using multiprocessing lock #
    else:
        # Acquire error lock and print #
        with STDERR_LOCK:
            print(f'* [ERROR] {msg} *', file=sys.stderr)


class RegexHandler:
    """
    Class object to store compiled regex patterns.
    """
    def __init__(self):
        # Compile misc regex #
        self.re_ip = re.compile(r'([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(?:\d{1,3}\.){3}\d{1,3}')
        self.re_hostname = re.compile(r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+'
                                      r'[a-zA-Z]{2,6}$')
        self.re_cidr = re.compile(r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}')
        self.re_ping_fail = re.compile(r'Nmap scan report for [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.'
                                       r'[0-9]{1,3} \[host down, received [a-z]{2,4}-[a-z]{4,8}')
        self.re_path = re.compile(r'^(?:/[a-zA-Z\d_\"\' .,\-]{1,260})+')
        self.re_proto = re.compile(r'https|http')
        self.re_md_line = re.compile(r'^\*{1,512}')

        # Set template private variables for repetitive text in patterns #
        __tcp_template = r'/tcp {2,6}open'
        __udp_template = r'/udp {2,6}open'
        __both_template = r'/(?:tcp|udp) {2,6}open'

        # Compile TCP port regex #
        self.re_ftp = re.compile(rf'(?:20|21){__tcp_template}')
        self.re_ssh = re.compile(rf'22{__tcp_template}')
        self.re_telnet = re.compile(rf'23{__tcp_template}')
        self.re_smtp = re.compile(rf'(?:25|465|587|2525){__tcp_template}')
        self.re_whois = re.compile(rf'43{__tcp_template}')
        self.re_finger = re.compile(rf'79{__tcp_template}')
        self.re_web = re.compile(rf'(?:80|443|8080|8443){__tcp_template}')
        self.re_pop3 = re.compile(rf'(?:110|995){__tcp_template}')
        self.re_ident = re.compile(rf'113{__tcp_template}')
        self.re_nntp = re.compile(rf'(?:119|433){__tcp_template}')
        self.re_imap = re.compile(rf'(?:143|993){__tcp_template}')
        self.re_smux = re.compile(rf'199{__tcp_template}')
        self.re_checkpoint_firewall = re.compile(rf'264{__tcp_template}')
        self.re_smb = re.compile(rf'445{__tcp_template}')
        self.re_modbus = re.compile(rf'502{__tcp_template}')
        self.re_rexec = re.compile(rf'512{__tcp_template}')
        self.re_rlogin = re.compile(rf'513{__tcp_template}')
        self.re_rsh = re.compile(rf'514{__tcp_template}')
        self.re_lpd = re.compile(rf'515{__tcp_template}')
        self.re_apple_filing = re.compile(rf'548{__tcp_template}')
        self.re_rtsp = re.compile(rf'554{__tcp_template}')
        self.re_cups = re.compile(rf'631{__tcp_template}')
        self.re_kerbv5_admin_tcp = re.compile(rf'749{__tcp_template}')
        self.re_kerbv4_passwd_tcp = re.compile(rf'761{__tcp_template}')
        self.re_rsync = re.compile(rf'873{__tcp_template}')
        self.re_iis = re.compile(rf'1025{__tcp_template}')
        self.re_mssql = re.compile(rf'1433{__tcp_template}')
        self.re_oracle_db = re.compile(rf'1521{__tcp_template}')
        self.re_oracle_xmldb = re.compile(rf'2100{__tcp_template}')
        self.re_sql = re.compile(rf'3306{__tcp_template}')
        self.re_oracle_web = re.compile(rf'3339{__tcp_template}')
        self.re_rdp = re.compile(rf'3389{__tcp_template}')
        self.re_adb = re.compile(rf'(?:5037|5555){__tcp_template}')
        self.re_vnc = re.compile(rf'(?:5800|5900){__tcp_template}')
        self.re_winrm = re.compile(rf'(?:5985|5986){__tcp_template}')
        self.re_irc_tcp = re.compile(rf'6667{__tcp_template}')
        self.re_ad_admin = re.compile(rf'9389{__tcp_template}')

        # Compile UDP port regex #
        self.re_dhcp = re.compile(rf'67{__udp_template}')
        self.re_tftp = re.compile(rf'69{__udp_template}')
        self.re_kerbv5_passwd_udp = re.compile(rf'464{__udp_template}')
        self.re_ipsec_ike_vpn = re.compile(rf'500{__udp_template}')
        self.re_kerbv5_ticket_udp = re.compile(rf'4444{__udp_template}')
        self.re_mdns = re.compile(rf'5353{__udp_template}')

        # Compile TCP/UDP port regex #
        self.re_wins = re.compile(rf'42{__both_template}')
        self.re_dns = re.compile(rf'53{__both_template}')
        self.re_kerbv5_ticket = re.compile(rf'88{__both_template}')
        self.re_rpc = re.compile(rf'111{__both_template}')
        self.re_ntp = re.compile(rf'123{__both_template}')
        self.re_msrpc = re.compile(rf'135{__both_template}')
        self.re_netbios_name = re.compile(rf'137{__both_template}')
        self.re_netbios_sesh = re.compile(rf'139{__both_template}')
        self.re_snmp = re.compile(rf'(?:161|162|10161|10162){__both_template}')
        self.re_irc = re.compile(rf'(?:194|529){__both_template}')
        self.re_ldap = re.compile(rf'(?:389|636){__both_template}')
        self.re_kerbv4_ticket = re.compile(rf'750{__both_template}')
        self.re_kerbv4_admin = re.compile(rf'751{__both_template}')
        self.re_windomain_indicator = re.compile(rf'(?:1030|1032|1033|1038){__both_template}')
        self.re_oracle_agent = re.compile(rf'(?:1748|1754|1808|1809){__both_template}')
        self.re_nfs = re.compile(rf'2049{__both_template}')
        self.re_globalcat_ldap = re.compile(rf'(?:3268|3269){__both_template}')
        self.re_upnotifyp = re.compile(rf'4445{__both_template}')
        self.re_rsip = re.compile(rf'4555{__both_template}')
        self.re_wsdapi = re.compile(rf'5357{__both_template}')
        self.re_dfsr = re.compile(rf'5722{__both_template}')
        self.re_wrms = re.compile(rf'47001{__both_template}')

    def scan_parse(self, scan_output: str) -> dict:
        """
        Takes the nmap scan output and performs regex matches to identify open ports.
        The result is returned in a dictionary with mapped comma separated ports.

        :param scan_output:  The nmap scan output that is passed in to matched with regex for
                             open ports.
        :return:  The mapped port number to regex match result dictionary.
        """
        return {
            # TCP port regex matches #
            '20,21': re.search(self.re_ftp, scan_output),
            '22': re.search(self.re_ssh, scan_output),
            '23': re.search(self.re_telnet, scan_output),
            '25,465,587,2525': re.search(self.re_smtp, scan_output),
            '43': re.search(self.re_whois, scan_output),
            '79': re.search(self.re_finger, scan_output),
            '80,443,8080,8443': re.search(self.re_web, scan_output),
            '110,995': re.search(self.re_pop3, scan_output),
            '113': re.search(self.re_ident, scan_output),
            '119,433': re.search(self.re_nntp, scan_output),
            '143,993': re.search(self.re_imap, scan_output),
            '199': re.search(self.re_smux, scan_output),
            '264': re.search(self.re_checkpoint_firewall, scan_output),
            '445': re.search(self.re_smb, scan_output),
            '502': re.search(self.re_modbus, scan_output),
            '512': re.search(self.re_rexec, scan_output),
            '513': re.search(self. re_rlogin, scan_output),
            '514': re.search(self.re_rsh, scan_output),
            '515': re.search(self.re_lpd, scan_output),
            '548': re.search(self.re_apple_filing, scan_output),
            '554': re.search(self.re_rtsp, scan_output),
            '631': re.search(self.re_cups, scan_output),
            '749': re.search(self.re_kerbv5_admin_tcp, scan_output),
            '761': re.search(self.re_kerbv4_passwd_tcp, scan_output),
            '873': re.search(self.re_rsync, scan_output),
            '1025': re.search(self.re_iis, scan_output),
            '1433': re.search(self.re_mssql, scan_output),
            '1521': re.search(self.re_oracle_db, scan_output),
            '2100': re.search(self.re_oracle_xmldb, scan_output),
            '3306': re.search(self.re_sql, scan_output),
            '3339': re.search(self.re_oracle_web, scan_output),
            '3389': re.search(self.re_rdp, scan_output),
            '5037,5555': re.search(self.re_adb, scan_output),
            '5800,5900': re.search(self.re_vnc, scan_output),
            '5985,5986': re.search(self.re_winrm, scan_output),
            '6667': re.search(self.re_irc_tcp, scan_output),
            '9389': re.search(self.re_ad_admin, scan_output),

            # UDP port regex matches #
            '67': re.search(self.re_dhcp, scan_output),
            '69': re.search(self.re_tftp, scan_output),
            '464': re.search(self.re_kerbv5_passwd_udp, scan_output),
            '500': re.search(self.re_ipsec_ike_vpn, scan_output),
            '4444': re.search(self.re_kerbv5_ticket_udp, scan_output),
            '5353': re.search(self.re_mdns, scan_output),

            # TCP/UDP port regex matches #
            '42': re.search(self.re_wins, scan_output),
            '53': re.search(self.re_dns, scan_output),
            '88': re.search(self.re_kerbv5_ticket, scan_output),
            '111': re.search(self.re_rpc, scan_output),
            '123': re.search(self.re_ntp, scan_output),
            '135': re.search(self.re_msrpc, scan_output),
            '137': re.search(self.re_netbios_name, scan_output),
            '139': re.search(self.re_netbios_sesh, scan_output),
            '161,162,10161,10162': re.search(self.re_snmp, scan_output),
            '194,529': re.search(self.re_irc, scan_output),
            '389,636': re.search(self.re_ldap, scan_output),
            '750': re.search(self.re_kerbv4_ticket, scan_output),
            '751': re.search(self.re_kerbv4_admin, scan_output),
            '1030,1032,1033,1038': re.search(self.re_windomain_indicator, scan_output),
            '1748,1754,1808,1809': re.search(self.re_oracle_agent, scan_output),
            '2049': re.search(self.re_nfs, scan_output),
            '3268,3269': re.search(self.re_globalcat_ldap, scan_output),
            '4445': re.search(self.re_upnotifyp, scan_output),
            '4555': re.search(self.re_rsip, scan_output),
            '5357': re.search(self.re_wsdapi, scan_output),
            '5722': re.search(self.re_dfsr, scan_output),
            '47001': re.search(self.re_wrms, scan_output)
        }


def service_handler(conf_obj: object, reg_obj: object, logger_tuple: tuple, commands: list,
                    custom_commands: list, out_path: Path, cmd_args: list):
    """
    Takes passed in service information and executes commands parsed from yaml config file.

    :param conf_obj:  The program configuration instance.
    :param reg_obj:  The compiled regex instance.
    :param logger_tuple:  The console and scan process logger in tuple grouping.
    :param commands:  The commands to be executed that are based off the system path.
    :param custom_commands:  The commands to be executed that are bassed off custom program dir.
    :param out_path:  The path to the file where the output will be stored.
    :param cmd_args:  The cmd args to parsed in command (required: ip,port  optional: protocol)
    :return:  Nothing
    """
    # Iterate through ftp commands from yaml file #
    for command in (commands + custom_commands):
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in conf_obj.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, reg_obj, *cmd_args)

        # If the command is based on system path #
        if command not in custom_commands:
            # Execute system command #
            output = system_cmd(command, None, conf_obj, reg_obj, logger_tuple[1])
        # If the command is a program in set custom programs folder #
        else:
            # Execute system command #
            output = system_cmd(command, None, conf_obj, reg_obj, logger_tuple[1], is_custom=True)

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            logger_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], cmd_args[0])
            data = f'>> {command}\n{"*" * (len(command) + 4)}\n{output.decode()}\n\n\n'
            # Write the output with command title to service file #
            file_handler(out_path, 'a', logger_tuple[1], data=data)


def system_cmd(cmd: str, exec_time, conf_obj: object, reg_obj: object, logger: logging.Logger,
               is_custom=False) -> bytes | bool:
    """
    Executes system shell command and returns the output. If improper data type is in command syntax
    list or error occurs during command execution, the error is displayed via stderr and logged,
    and False is returned to indicated failed operation.

    :param cmd:  The command to be executed.
    :param exec_time:  The execution timeout to prevent process hangs.
    :param conf_obj:  The program configuration instance.
    :param reg_obj:  The compiled regex storage instance.
    :param logger:  The logger instance.
    :param is_custom:  Boolean kwarg for executing custom scripts.
    :return:  Either output data or bool False when fatal error occurs.
    """
    # If custom program boolean and was parsed from config file #
    if is_custom and conf_obj.custom_program_path:
        # If there is no path delimiter in command #
        if '<path>' not in cmd:
            # Format custom path to program in beginning of string #
            cmd = f'{conf_obj.custom_program_path}/{cmd}'
        # If there is a path delimiter to be parsed in command #
        else:
            # Format path to program where specified in command string #
            cmd = cmd_parser(cmd, reg_obj, conf_obj.custom_program_path)

    try:
        # Set up child process in context manager, piping output & errors to return variables #
        with Popen(f'{cmd} &', executable=conf_obj.shell, stdout=PIPE, stderr=PIPE,
                   shell=True) as command:
            # Execute process for passed in timeout (None=blocking) #
            out, err = command.communicate(timeout=exec_time)

    # If the process times out #
    except TimeoutExpired:
        # Print error and log #
        print_err(f'Process for {cmd} timed out before finishing execution', is_locked=True)
        logger.log(logging.ERROR, 'Process for %s timed out before finishing execution', cmd)

    # If the input command has data other than string #
    except TypeError:
        # Print error and log #
        print_err(f'Input in {cmd} contains data type other than string', is_locked=True)
        logger.log(logging.ERROR, 'Input in %s contains data type other than string', cmd)
        return False

    # If the child process returned error #
    if err:
        # Log error and return failed operation #
        logger.log(logging.ERROR, 'Error occurred during child process execution: %s',
                   err.decode().strip())

    return out.strip()
