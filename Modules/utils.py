""" Built-in modules """
import errno
import logging
import re
import shlex
import sys
from pathlib import Path
from subprocess import Popen, CalledProcessError, SubprocessError, TimeoutExpired


class CompiledRegex:
    ''' Compile TCP port regex '''
    # Regex for matching ftp port #
    re_ftp = re.compile(r'(?:20|21)/tcp {2,6}open')
    # Regex for matching ssh port #
    re_ssh = re.compile(r'22/tcp {2,6}open')
    # Regex for matching telnet #
    re_telnet = re.compile(r'23/tcp {2,6}open')
    # Regex for matching http(s) web ports #
    re_web = re.compile(r'(?:443|80|8080|8443)/tcp {2,6}open')
    # Regex for matching sql port #
    re_sql = re.compile(r'3306/tcp {2,6}open')

   # ''' Compile UDP port regex '''
   #
   # ''' Compile TCP/UDP port regex '''


def error_query(err_path: str, err_mode: str, err_obj: object):
    """
    Looks up the errno message to get description.

    :param err_path:  The path to the file where error occurred.
    :param err_mode:  The file mode used during error.
    :param err_obj:  The error instance passed in from occurrence.
    :return:  Nothing
    """
    # If file does not exist #
    if err_obj.errno == errno.ENOENT:
        print_err(f'{err_path} does not exist')
        logging.exception('%s does not exist\n\n', err_path)
        sys.exit(2)

    # If the file does not have read/write access #
    elif err_obj.errno == errno.EPERM:
        print_err(f'{err_path} does not have permissions for {err_mode} file mode, if file exists '
                 'confirm it is closed')
        logging.exception('%s does not have permissions for %s file mode\n\n', err_path, err_mode)
        sys.exit(3)

    # File IO error occurred #
    elif err_obj.errno == errno.EIO:
        print_err(f'IO error occurred during {err_mode} mode on {err_path}')
        logging.exception(f'IO error occurred during %s mode on %s\n\n', err_mode, err_path)
        sys.exit(4)

    # If other unexpected file operation occurs #
    else:
        print_err(f'Unexpected file operation occurred accessing {err_path}: {err_obj.errno}')
        logging.exception('Unexpected file operation occurred accessing %s: %s\n\n', err_path,
                          err_obj.errno)
        sys.exit(5)


def file_handler(file_path: Path, mode: str, data=None) -> str | None:
    """
    Read/Write file operation handler.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to performed on file.
    :param data:  Optional data param for writing data to file.
    :return:  Read data on read or None for write.
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                return file.read()
            # If file mode is write operation #
            else:
                # If there is no data to write #
                if not data:
                    # Print error, log, and exit #
                    print_err(f'Attempting to write to {file_path.name} with no data')
                    logging.error('Attempting to write to %s with no data\n\n', file_path.name)
                    sys.exit(6)

                file.write(data)

            # Not necessary but follows pylint return all or nothing rule #
            return None

    # If error occurs during file operation #
    except (IOError, OSError) as err:
        # Look up file error based on low-level descriptor #
        error_query(str(file_path.resolve()), mode, err)


class ProgramPaths:
    # Establish program paths #
    cwd = Path.cwd()
    out_dir = cwd / 'Output'
    exploit_dir = out_dir / 'Exploits'
    loot_dir = out_dir / 'Loot'
    report_dir = out_dir / 'Reports'
    pic_dir = report_dir / 'Screenshots'
    scan_dir = out_dir / 'ScanOutput'
    log_file = cwd / 'pentester_automater.log'


def print_err(msg: str):
    """
    Displays the error message through stderr (standard error).

    :param msg:  The error message to be displayed.
    :return:  Nothing
    """
    print(f'\n* [ERROR] {msg} *\n', file=sys.stderr)


def system_cmd(cmd: str, stdout, stderr, exec_time: int, out_file=None):
    """
    Executes shell-escaped system command with the ability to redirect output to a file for
    generating scan reports.

    :param cmd:  The command to be executed.
    :param stdout:  The child process standard output.
    :param stderr:  The child process standard error.
    :param exec_time:  The execution timeout to prevent process hangs.
    :param out_file:  The output file where the results are stored.
    :return:  Nothing
    """
    # Shell escape command string #
    exe = shlex.quote(cmd)
    command = None

    try:
        # If the output is to be written to a file #
        if out_file:
            # Create output file in write mode #
            with open(out_file, 'w') as file:
                # TODO use the log file as stderr
                command = Popen(exe, stdout=file, stderr=stderr, shell=False)
                command.communicate(timeout=exec_time)
        # If the command is executed without file redirect #
        else:
            command = Popen(exe, stdout=stdout, stderr=stderr, shell=False)
            command.communicate(timeout=exec_time)

    # If error occurs during file operation #
    except (IOError, OSError) as file_err:
        error_query(str(out_file.resolve()), 'w', file_err)

    # Handles process timeouts and errors #
    except (SubprocessError, TimeoutExpired, CalledProcessError, OSError, ValueError) as proc_err:
        command.kill()
        command.communicate()

        # If error is of significance (non-timeout) #
        if not TimeoutExpired:
            print_err(f'Error occurred during child process execution: {proc_err}')
            logging.exception('Error occurred during child process execution: %s\n\n', proc_err)
            sys.exit(7)
