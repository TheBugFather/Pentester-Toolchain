""" Built-in modules """
import errno
import logging
import shlex
import sys
from pathlib import Path
from subprocess import Popen, CalledProcessError, SubprocessError, TimeoutExpired


def error_query(err_path: str, err_mode: str, err_obj):
    """
    Looks up the errno message to get description.

    :param err_path:  The path to the file where error occurred.
    :param err_mode:  The file mode used during error.
    :param err_obj:  The error instance passed in from occurrence.
    :return:  Nothing
    """
    # If file does not exist #
    if err_obj.errno == errno.ENOENT:
        print_err(f'{err_path} does not exist')
        logging.exception(f'{err_path} does not exist\n\n')
        sys.exit(2)

    # If the file does not have read/write access #
    elif err_obj.errno == errno.EPERM:
        print_err(f'{err_path} does not have permissions for {err_mode} file mode, if file exists '
                 'confirm it is closed')
        logging.exception(f'{err_path} does not have permissions for {err_mode} file mode\n\n')
        sys.exit(3)

    # File IO error occurred #
    elif err_obj.errno == errno.EIO:
        print_err(f'IO error occurred during {err_mode} mode on {err_path}')
        logging.exception(f'IO error occurred during {err_mode} mode on {err_path}\n\n')
        sys.exit(4)

    # If other unexpected file operation occurs #
    else:
        print_err(f'Unexpected file operation occurred accessing {err_path}: {err_obj.errno}')
        logging.exception(f'Unexpected file operation occurred accessing {err_path}: '
                          f'{err_obj.errno}\n\n')
        sys.exit(5)


def file_handler(file_path: Path, mode: str, data=None):
    """
    Read/Write file operation handler.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to performed on file.
    :param data:  Optional data param for writing data to file.
    :return:
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file:
            # If read operation
            if mode == 'r':
                return file.read()
            # If write operation #
            else:
                # If there is no data to write #
                if not data:
                    # Print error, log, and exit #
                    print_err(f'Attempting to write to {file_path.name} with no data')
                    logging.error('Attempting to write to %s with no data\n\n', file_path.name)
                    sys.exit(6)

                file.write(data)

    # If error occurs during file operation #
    except (IOError, OSError) as err:
        # Look up file error based on low-level descriptor #
        error_query(str(file_path.resolve()), mode, err)


def print_err(msg: str):
    """
    Displays the error message through stderr (standard error).

    :param msg:  The error message to be displayed.
    :return:  Nothing
    """
    print(f'\n* [ERROR] {msg} *\n', file=sys.stderr)


def system_cmd(cmd: str, stdout, stderr, exec_time: int, out_file=None):
    """
    Executes shell-escaped system command with the ability to redirect output to a file for
    generating scan reports.

    :param cmd:  The command to be executed.
    :param stdout:  The child process standard output.
    :param stderr:  The child process standard error.
    :param exec_time:  The execution timeout to prevent process hangs.
    :param out_file:  The output file where the results are stored.
    :return:  Nothing
    """
    # Shell escape command string #
    exe = shlex.quote(cmd)
    command = None

    try:
        # If the output is to be written to a file #
        if out_file:
            # Create output file in write mode #
            with open(out_file, 'w') as file:
                # TODO use the log file as stderr
                command = Popen(exe, stdout=file, stderr=stderr, shell=False)
                command.communicate(timeout=exec_time)
        else:
            # To execute a regular command #
            command = Popen(exe, stdout=stdout, stderr=stderr, shell=False)
            command.communicate(timeout=exec_time)

    # If error occurs during file operation #
    except (IOError, OSError) as file_err:
        error_query(str(out_file.resolve()), 'w', file_err)

    # Handles process timeouts and errors #
    except (SubprocessError, TimeoutExpired, CalledProcessError, OSError, ValueError) as proc_err:
        command.kill()
        command.communicate()

        # If error is of significance (non-timeout) #
        if not TimeoutExpired:
            print_err(f'Error occurred during child process execution: {proc_err}')
            logging.exception('Error occurred during child process execution: %s\n\n', proc_err)
            sys.exit(7)
