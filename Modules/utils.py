# pylint: disable=E1131,R1719
""" Built-in modules """
import aiofiles
import asyncio
import asyncio.subprocess as sub_proc
import logging
import os
import re
import sys
from pathlib import Path
# External modules #
from yaml import safe_load


async def async_file_handler(file_path: Path, mode: str, data=None) -> bytes | str | None:
    """
    Read/Write asyncio-based file operation handler.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to perform on the file.
    :param data:  Kwarg data param for writing data to the file.
    :return:  Read file string or bytes data on read, and None for write.
    """
    try:
        # Open file path as async file handle #
        async with aiofiles.open(file_path, mode=mode) as file_handle:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                return await file_handle.read()

            # If there is no data to write #
            if not data:
                # Print error, log, and exit #
                print_err(f'Attempting to write to {file_path.name} with no data')
                logging.error('Attempting to write to %s with no data', file_path.name)
                sys.exit(11)

            await file_handle.write(data)

    # If error occurs during file operation #
    except OSError as file_err:
        # Print error, log, and exit #
        print(f'Error occurred during async file operation: {file_err}')
        logging.error('Error occurred during async file operation: %s', file_err)
        sys.exit(5)


async def async_proc_exec(command: str, conf_obj: object, is_custom=False) -> bytes:
    """
    Executes a system command as a child process in a asynchronous fashion.

    :param command:  The command to be executed async.
    :param conf_obj:  The program configuration instance.
    :param is_custom:  Boolean toggle to specify whether the command to be executed uses a custom
                       file path not tied to the env PATH variable.
    :return:  Nothing
    """
    # If custom program boolean toggle and path was parsed from config file #
    if is_custom and conf_obj.custom_program_path:
        # If there is no path delimiter in command #
        if '<path>' not in command:
            # Format custom path to program in beginning of string #
            command = f'{conf_obj.custom_program_path}/{command}'
        # If there is a path delimiter to be parsed in command #
        else:
            # Format path to program where specified in command string #
            command = command.replace('<path>', conf_obj.custom_program_path)

    # Establish async context manager for subprocess execution #
    async_proc = await asyncio.create_subprocess_shell(command, stdout=sub_proc.PIPE,
                                                       stderr=sub_proc.PIPE)
    # Execute the subprocess command piping any output and errors to variables #
    stdout, stderr = await async_proc.communicate()

    # If an error occurred during subprocess execution #
    if stderr:
        # Strip newlines and decode error to plain text #
        stderr_plain = stderr.strip().decode(errors='replace')
        # Print and log the error #
        print(f'Error occurred during async subprocess execution: {stderr_plain}')
        logging.error('Error occurred during async subprocess execution: %s', stderr_plain)

    return stdout.strip()


async def cmd_parser(yaml_syntax: str, reg_obj: object, *args) -> str:
    """
    Take input command parsed from yaml file, and parses in any delimiters in the command with
    passed in variable length parameters.

    :param yaml_syntax:  The command from yaml file to be delimiter parsed.
    :param reg_obj:  The compiled regex pattern object.
    :param args:  The passed in variable-length arguments.
    :return:  The parsed command to be executed.
    """
    parsed_cmd = ''

    # Iterate through passed in variable length args #
    for arg in args:
        # Ensure the arg is string format #
        arg = str(arg)

        # If ip delimiter is in passed in yaml command and arg matches ip regex #
        if '<ip>' in yaml_syntax and re.search(reg_obj.re_ip, arg):
            # Parse in ip arg into command syntax and loop to next arg #
            parsed_cmd = await syntax_parse(parsed_cmd, yaml_syntax, '<ip>', arg)
            continue

        try:
            # Attempt to convert arg to string #
            int_port = int(arg)

            # If port delimiter is in passed in yaml command and arg matches port regex #
            if '<port>' in yaml_syntax and 20 <= int_port <= 47001:
                # Parse in ip arg into command syntax and loop to next arg #
                parsed_cmd = await syntax_parse(parsed_cmd, yaml_syntax, '<port>', arg)
                continue

        # If the str arg is not base10 decimal #
        except ValueError:
            pass

        # If domain delimiter is in passed in yaml command and arg matches domain regex #
        if '<domain>' in yaml_syntax and re.search(reg_obj.re_domain, arg):
            # Parse in ip arg into command syntax and loop to next arg #
            parsed_cmd = await syntax_parse(parsed_cmd, yaml_syntax, '<domain>', arg)
            continue

        # If path delimiter is in passed in yaml command and arg matches protocol regex #
        if '<proto>' in yaml_syntax and re.search(reg_obj.re_proto, arg):
            # Parse in ip arg into command syntax and loop to next arg #
            parsed_cmd = await syntax_parse(parsed_cmd, yaml_syntax, '<proto>', arg)

    return parsed_cmd


class ConfigClass:
    """
    Class to store yaml file configurations that are referenced throughout operations.

    :param cwd:  The current working directory.
    :param yaml_data:  Dict data from yaml file to be parsed into config class.
    """
    def __init__(self, cwd: Path, yaml_data: dict):
        # Program initialization variables #
        self.max_tasks = yaml_data['init']['max_tasks']
        self.ports = yaml_data['init']['ports']
        self.nmap_init = yaml_data['init']['nmap_init']
        self.nmap_final = yaml_data['init']['nmap_final']
        self.markdown = yaml_data['init']['generate_markdown']
        # Set the command delimiters #
        self.delimiters = ('<ip>', '<port>', '<domain>', '<proto>')
        # Set the current shell environment #
        self.shell = os.environ.get('SHELL')
        # Set the current working directory #
        self.cwd = cwd
        # Set the output directory and ensure it exists #
        self.out_dir = self.cwd / 'Output'
        self.out_dir.mkdir(parents=True, exist_ok=True)
        # Set the template storage directory path #
        __storage_path = Path(self.cwd / 'Stored')
        # If template storage directory missing, create it #
        if not __storage_path.exists():
            __storage_path.mkdir(parents=True, exist_ok=True)

        # Set client scan template directory path #
        __template_path = self.cwd / 'Active'
        # If the client scan template path exists #
        if __template_path.exists():
            # If the client scan template path has files #
            if any(__template_path.iterdir()):
                self.template_path = __template_path
            # If there are no client scan templates in folder #
            else:
                # Print error and exit #
                print_err('Organizational templates directory missing client scan templates')
                sys.exit(2)
        # If the client scan template path does not exist or is empty #
        else:
            # Create the missing directory #
            __template_path.mkdir(parents=True)
            # Print error and exit #
            print_err('Organizational template directory missing from program directory')
            sys.exit(2)

        # Set custom programs directory path #
        __custom_path = self.cwd / 'CustomPrograms'
        # If the custom program path exists #
        if __custom_path.exists():
            # If the custom program path has files #
            if any(__custom_path.iterdir()):
                self.custom_program_path = __custom_path.name
            # If there are no custom programs in dir #
            else:
                self.custom_program_path = False
        # If the custom program path does not exist or is empty #
        else:
            # Create the missing directory #
            __custom_path.mkdir(parents=True)
            self.custom_program_path = False

        # TCP based port commands #
        self.ftp = yaml_data['ftp']['commands']
        self.ftp_custom = yaml_data['ftp']['custom_commands']
        self.ssh = yaml_data['ssh']['commands']
        self.ssh_custom = yaml_data['ssh']['custom_commands']
        self.telnet = yaml_data['telnet']['commands']
        self.telnet_custom = yaml_data['telnet']['custom_commands']
        self.smtp = yaml_data['smtp']['commands']
        self.smtp_custom = yaml_data['smtp']['custom_commands']
        self.whois = yaml_data['whois']['commands']
        self.whois_custom = yaml_data['whois']['custom_commands']
        self.finger = yaml_data['finger']['commands']
        self.finger_custom = yaml_data['finger']['custom_commands']
        self.web = yaml_data['web']['commands']
        self.web_custom = yaml_data['web']['custom_commands']
        self.pop3 = yaml_data['pop3']['commands']
        self.pop3_custom = yaml_data['pop3']['custom_commands']
        self.ident = yaml_data['ident']['commands']
        self.ident_custom = yaml_data['ident']['custom_commands']
        self.nntp = yaml_data['nntp']['commands']
        self.nntp_custom = yaml_data['nntp']['custom_commands']
        self.imap = yaml_data['imap']['commands']
        self.imap_custom = yaml_data['imap']['custom_commands']
        self.smux = yaml_data['smux']['commands']
        self.smux_custom = yaml_data['smux']['custom_commands']
        self.checkpoint_firewall = yaml_data['checkpoint_firewall']['commands']
        self.checkpoint_firewall_custom = yaml_data['checkpoint_firewall']['custom_commands']
        self.smb = yaml_data['smb']['commands']
        self.smb_custom = yaml_data['smb']['custom_commands']
        self.modbus = yaml_data['modbus']['commands']
        self.modbus_custom = yaml_data['modbus']['custom_commands']
        self.rlogin = yaml_data['rlogin']['commands']
        self.rlogin_custom = yaml_data['rlogin']['custom_commands']
        self.rsh = yaml_data['rsh']['commands']
        self.rsh_custom = yaml_data['rsh']['custom_commands']
        self.apple_filing = yaml_data['apple_filing']['commands']
        self.apple_filing_custom = yaml_data['apple_filing']['custom_commands']
        self.rtsp = yaml_data['rtsp']['commands']
        self.rtsp_custom = yaml_data['rtsp']['custom_commands']
        self.cups = yaml_data['cups']['commands']
        self.cups_custom = yaml_data['cups']['custom_commands']
        self.rsync = yaml_data['rsync']['commands']
        self.rsync_custom = yaml_data['rsync']['custom_commands']
        self.java_rmi = yaml_data['java_rmi']['commands']
        self.java_rmi_custom = yaml_data['java_rmi']['custom_commands']
        self.mssql = yaml_data['mssql']['commands']
        self.mssql_custom = yaml_data['mssql']['custom_commands']
        self.oracle_db = yaml_data['oracle_db']['commands']
        self.oracle_db_custom = yaml_data['oracle_db']['custom_commands']
        self.oracle_xml_db = yaml_data['oracle_xml_db']['commands']
        self.oracle_xml_db_custom = yaml_data['oracle_xml_db']['custom_commands']
        self.docker = yaml_data['docker']['commands']
        self.docker_custom = yaml_data['docker']['custom_commands']
        self.squid = yaml_data['squid']['commands']
        self.squid_custom = yaml_data['squid']['custom_commands']
        self.iscsi = yaml_data['iscsi']['commands']
        self.iscsi_custom = yaml_data['iscsi']['custom_commands']
        self.sap_router = yaml_data['sap_router']['commands']
        self.sap_router_custom = yaml_data['sap_router']['custom_commands']
        self.sql = yaml_data['sql']['commands']
        self.sql_custom = yaml_data['sql']['custom_commands']
        self.rdp = yaml_data['rdp']['commands']
        self.rdp_custom = yaml_data['rdp']['custom_commands']
        self.distcc = yaml_data['distcc']['commands']
        self.distcc_custom = yaml_data['distcc']['custom_commands']
        self.subversion = yaml_data['subversion']['commands']
        self.subversion_custom = yaml_data['subversion']['custom_commands']
        self.epmd = yaml_data['epmd']['commands']
        self.epmd_custom = yaml_data['epmd']['custom_commands']
        self.cisco_smart_install = yaml_data['cisco_smart_install']['commands']
        self.cisco_smart_install_custom = yaml_data['cisco_smart_install']['custom_commands']
        self.postgresql = yaml_data['postgresql']['commands']
        self.postgresql_custom = yaml_data['postgresql']['custom_commands']
        self.redshift = yaml_data['redshift']['commands']
        self.redshift_custom = yaml_data['redshift']['custom_commands']
        self.vnc = yaml_data['vnc']['commands']
        self.vnc_custom = yaml_data['vnc']['custom_commands']
        self.winrm = yaml_data['winrm']['commands']
        self.winrm_custom = yaml_data['winrm']['custom_commands']
        self.x11 = yaml_data['x11']['commands']
        self.x11_custom = yaml_data['x11']['custom_commands']
        self.redis = yaml_data['redis']['commands']
        self.redis_custom = yaml_data['redis']['custom_commands']
        self.java_debug_wire = yaml_data['java_debug_wire']['commands']
        self.java_debug_wire_custom = yaml_data['java_debug_wire']['custom_commands']
        self.apache_jserv = yaml_data['apache_jserv']['commands']
        self.apache_jserv_custom = yaml_data['apache_jserv']['custom_commands']
        self.influxdb = yaml_data['influxdb']['commands']
        self.influxdb_custom = yaml_data['influxdb']['custom_commands']
        self.bitcoin = yaml_data['bitcoin']['commands']
        self.bitcoin_custom = yaml_data['bitcoin']['custom_commands']
        self.apache_casandra = yaml_data['apache_casandra']['commands']
        self.apache_casandra_custom = yaml_data['apache_casandra']['custom_commands']
        self.raw_printing = yaml_data['raw_printing']['commands']
        self.raw_printing_custom = yaml_data['raw_printing']['custom_commands']
        self.elastic_search = yaml_data['elastic_search']['commands']
        self.elastic_search_custom = yaml_data['elastic_search']['custom_commands']
        self.ndmp = yaml_data['ndmp']['commands']
        self.ndmp_custom = yaml_data['ndmp']['custom_commands']
        self.memcache = yaml_data['memcache']['commands']
        self.memcache_custom = yaml_data['memcache']['custom_commands']
        self.gluster_fs = yaml_data['gluster_fs']['commands']
        self.gluster_fs_custom = yaml_data['gluster_fs']['custom_commands']
        self.mongo_db = yaml_data['mongo_db']['commands']
        self.mongo_db_custom = yaml_data['mongo_db']['custom_commands']
        self.hadoop = yaml_data['hadoop']['commands']
        self.hadoop_custom = yaml_data['hadoop']['custom_commands']

        # UDP based port commands #
        self.dhcp = yaml_data['dhcp']['commands']
        self.dhcp_custom = yaml_data['dhcp']['custom_commands']
        self.tftp = yaml_data['tftp']['commands']
        self.tftp_custom = yaml_data['tftp']['custom_commands']
        self.ruserd = yaml_data['ruserd']['commands']
        self.ruserd_custom = yaml_data['ruserd']['custom_commands']
        self.ws_discovery = yaml_data['ws_discovery']['commands']
        self.ws_discovery_custom = yaml_data['ws_discovery']['custom_commands']
        self.mdns = yaml_data['mdns']['commands']
        self.mdns_custom = yaml_data['mdns']['custom_commands']
        self.bacnet = yaml_data['bacnet']['commands']
        self.bacnet_custom = yaml_data['bacnet']['custom_commands']

        # TCP/UDP based port commands #
        self.dns = yaml_data['dns']['commands']
        self.dns_custom = yaml_data['dns']['custom_commands']
        self.kerberos = yaml_data['kerberos']['commands']
        self.kerberos_custom = yaml_data['kerberos']['custom_commands']
        self.rpc = yaml_data['rpc']['commands']
        self.rpc_custom = yaml_data['rpc']['custom_commands']
        self.ntp = yaml_data['ntp']['commands']
        self.ntp_custom = yaml_data['ntp']['custom_commands']
        self.msrpc = yaml_data['msrpc']['commands']
        self.msrpc_custom = yaml_data['msrpc']['custom_commands']
        self.netbios = yaml_data['netbios']['commands']
        self.netbios_custom = yaml_data['netbios']['custom_commands']
        self.snmp = yaml_data['snmp']['commands']
        self.snmp_custom = yaml_data['snmp']['custom_commands']
        self.irc = yaml_data['irc']['commands']
        self.irc_custom = yaml_data['irc']['custom_commands']
        self.ldap = yaml_data['ldap']['commands']
        self.ldap_custom = yaml_data['ldap']['custom_commands']
        self.ipsec_ike_vpn = yaml_data['ipsec_ike_vpn/pptp']['commands']
        self.ipsec_ike_vpn_custom = yaml_data['ipsec_ike_vpn/pptp']['custom_commands']
        self.ipmi = yaml_data['ipmi']['commands']
        self.ipmi_custom = yaml_data['ipmi']['custom_commands']
        self.socks_proxy = yaml_data['socks_proxy']['commands']
        self.socks_proxy_custom = yaml_data['socks_proxy']['custom_commands']
        self.nfs = yaml_data['nfs']['commands']
        self.nfs_custom = yaml_data['nfs']['custom_commands']
        self.rabbit_mq = yaml_data['rabbit_mq']['commands']
        self.rabbit_mq_custom = yaml_data['rabbit_mq']['custom_commands']
        self.couchdb = yaml_data['couchdb']['commands']
        self.couchdb_custom = yaml_data['couchdb']['custom_commands']
        self.ethernet_ip = yaml_data['ethernet_ip']['commands']
        self.ethernet_ip_custom = yaml_data['ethernet_ip']['custom_commands']


def config_input(base_path: Path) -> Path:
    """
    Prompts user for yaml configuration to use for scan automation.

    :param base_path:  The base path to the current working directory.
    :return:  Validated configuration file path to be used for scans.
    """
    while True:
        # Gather user input to specify what config file to use #
        file_name = input('[+] Please enter the name of the config file to use or hit enter for '
                          'default config.yml file: ')

        # If the default file was selected (enter) #
        if not file_name:
            file_path = base_path / 'Configs' / 'config.yml'
        # For any input other than enter #
        else:
            # Format path with input config file name #
            file_path = base_path / 'Configs' / file_name

        # If the configs directory is missing #
        if not file_path.parent.exists():
            # Create it, print error, and exit #
            file_path.mkdir(parents=True, exist_ok=True)
            print_err('The Configs directory that contains templates used'
                      ' to configure the scanner functionality is missing')
            sys.exit(2)

        # If the input file does not exist or is not a yaml config file #
        if not file_path.exists() or not str(file_path).endswith('yml'):
            # Print error and re-iterate #
            print_err('Input file path does not exist .. try again')
            continue

        return file_path


def file_handler(file_path: Path, mode: str, data=None, yaml=False) -> bytes | str | dict | None:
    """
    Read/Write file operation handler for text and yaml file formats.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to perform on the file.
    :param data:  Kwarg data param for writing data to the file.
    :param yaml:  Kwarg boolean operator to handle yaml configuration files.
    :return:  Read file string or bytes data on read, dict if read and yaml is True, and None for
              write.
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file_handle:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                # If the file is text format #
                if not yaml:
                    # Return text data #
                    return file_handle.read()

                # Return Safe loaded YAML data #
                return safe_load(file_handle)

            # If there is no data to write #
            if not data:
                # Print error, log, and exit #
                print_err(f'Attempting to write to {file_path.name} with no data')
                logging.error('Attempting to write to %s with no data', file_path.name)
                sys.exit(10)

            # If attempting to overwrite yaml config file #
            if yaml:
                # Print error, log, and exit #
                print_err('Attempted to write to YAML configuration file')
                logging.error('Attempted to write to YAML configuration file')
                sys.exit(11)

            file_handle.write(data)

    # If error occurs during file operation #
    except OSError as file_err:
        # Print error, log, and exit #
        print(f'Error occurred during file operation: {file_err}')
        logging.error('Error occurred during file operation: %s', file_err)
        sys.exit(5)

    # Follows pylint return all or nothing rule #
    return None


def markdown_formatter(output_dir: Path, logger: logging.Logger, regex_obj):
    """
    Crawls recursively through output dir and converts text output file into markdown copy.

    :param output_dir:  The path to the output directory.
    :param logger:  The logger instance
    :param regex_obj:  The compiled regex instance.
    :return:  Nothing
    """
    # Iterate through dirs and files recursively in Output dir #
    for dir_path, _, file_names in os.walk(output_dir):
        # Iterate through files in current directory #
        for file in file_names:
            # If the current file is text #
            if file.endswith('.txt'):
                # Set the current file path #
                file_path = Path(dir_path) / file
                # Read the data from the text file #
                text_data = file_handler(file_path, 'r', logger)
                markdown_data = ''

                # Iterate through read text data #
                for line in text_data.split('\n'):
                    # If line starts with title delimiter #
                    if line.startswith('>>'):
                        # Add line with parsed markdown title format #
                        markdown_data += f'{line.replace(">>", "##")}\n'
                        continue

                    # Search line with regex for asterisk based delimiter line #
                    line_search = re.search(regex_obj.re_md_line, line)
                    # If the current line is the asterisk delimiter line #
                    if line_search:
                        # Replace asterisk delimiter line with markdown line #
                        parsed_line = re.sub(regex_obj.re_md_line, line, '---')
                        # Parse in line with title as header with proper spacing #
                        markdown_data += f'\n{parsed_line}\n'
                        continue

                    markdown_data += f'{line}\n'

                # Format markdown output file path and write to file #
                markdown_path = Path(dir_path) / file.replace('.txt', '.md')
                file_handler(markdown_path, 'w', data=markdown_data)


def print_err(msg: str):
    """
    Displays the error message through stderr (standard error) with multiprocessing locking support.

    :param msg:  The error message to be displayed.
    :return:  Nothing
    """
    print(f'* [ERROR] {msg} *', file=sys.stderr)


class RegexHandler:
    """
    Class object to store compiled regex patterns.
    """
    def __init__(self):
        # Compile misc regex #
        self.re_ip = re.compile(r'([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(?:\d{1,3}\.){3}\d{1,3}')
        self.re_domain = re.compile(r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+'
                                    r'[a-zA-Z]{2,6}$')
        self.re_ip_parse = re.compile(r'(?<=has address )([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|'
                                      r'(?:\d{1,3}\.){3}\d{1,3}')
        self.re_domain_parse = re.compile(r'(?<=pointer )(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}'
                                          r'[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}')
        self.re_host_discovery = re.compile(r'\(?[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\)?$'
                                            r'\nHost is up', re.M)
        self.re_proto = re.compile(r'https|http')
        self.re_md_line = re.compile(r'^\*{1,512}')

        # Set template private variables for repetitive text in patterns #
        __tcp_template = r'/tcp {1,4}open  '
        __udp_template = r'/udp {1,4}open  '
        __both_template = r'/(?:tcp|udp) {1,4}open  '

        # Compile TCP port regex #
        self.re_ftp = re.compile(rf'^(?:20|21){__tcp_template}', re.M)
        self.re_ssh = re.compile(rf'^22{__tcp_template}', re.M)
        self.re_telnet = re.compile(rf'^23{__tcp_template}', re.M)
        self.re_smtp = re.compile(rf'^(?:25|465|587|2525){__tcp_template}', re.M)
        self.re_whois = re.compile(rf'^43{__tcp_template}', re.M)
        self.re_finger = re.compile(rf'^79{__tcp_template}', re.M)
        self.re_web = re.compile(rf'^(?:80|443|8080|8443){__tcp_template}', re.M)
        self.re_pop3 = re.compile(rf'^(?:110|995){__tcp_template}', re.M)
        self.re_ident = re.compile(rf'^113{__tcp_template}', re.M)
        self.re_nntp = re.compile(rf'^(?:119|433){__tcp_template}', re.M)
        self.re_imap = re.compile(rf'^(?:143|993){__tcp_template}', re.M)
        self.re_smux = re.compile(rf'^199{__tcp_template}', re.M)
        self.re_checkpoint_firewall = re.compile(rf'^264{__tcp_template}', re.M)
        self.re_smb = re.compile(rf'^445{__tcp_template}', re.M)
        self.re_modbus = re.compile(rf'^502{__tcp_template}', re.M)
        self.re_rlogin = re.compile(rf'^513{__tcp_template}', re.M)
        self.re_rsh = re.compile(rf'^514{__tcp_template}', re.M)
        self.re_apple_filing = re.compile(rf'^548{__tcp_template}', re.M)
        self.re_rtsp = re.compile(rf'^554{__tcp_template}', re.M)
        self.re_cups = re.compile(rf'^631{__tcp_template}', re.M)
        self.re_kerbv5_admin_tcp = re.compile(rf'^749{__tcp_template}', re.M)
        self.re_kerbv4_passwd_tcp = re.compile(rf'^761{__tcp_template}', re.M)
        self.re_rsync = re.compile(rf'^873{__tcp_template}', re.M)
        self.re_java_rmi = re.compile(rf'^(?:1050|1098|1099){__tcp_template}', re.M)
        self.re_mssql = re.compile(rf'^1433{__tcp_template}', re.M)
        self.re_oracle_db = re.compile(rf'^1521{__tcp_template}', re.M)
        self.re_oracle_xmldb = re.compile(rf'^2100{__tcp_template}', re.M)
        self.re_docker = re.compile(rf'^(?:2375|2376){__tcp_template}', re.M)
        self.re_squid = re.compile(rf'^3128{__tcp_template}', re.M)
        self.re_iscsi = re.compile(rf'^3260{__tcp_template}', re.M)
        self.re_sap_router = re.compile(rf'^3299{__tcp_template}', re.M)
        self.re_sql = re.compile(rf'^3306{__tcp_template}', re.M)
        self.re_rdp = re.compile(rf'^3389{__tcp_template}', re.M)
        self.re_distcc = re.compile(rf'^3632{__tcp_template}', re.M)
        self.re_subversion = re.compile(rf'^3690{__tcp_template}', re.M)
        self.re_epmd = re.compile(rf'^4369{__tcp_template}', re.M)
        self.re_cisco_smart_install = re.compile(rf'^4786{__tcp_template}', re.M)
        self.re_postgresql = re.compile(rf'^(?:5432|5433){__tcp_template}', re.M)
        self.re_redshift = re.compile(rf'^5439{__tcp_template}', re.M)
        self.re_vnc = re.compile(rf'^(?:5800|5900){__tcp_template}', re.M)
        self.re_winrm = re.compile(rf'^(?:5985|5986){__tcp_template}', re.M)
        self.re_x11 = re.compile(rf'^6000{__tcp_template}', re.M)
        self.re_redis = re.compile(rf'^6379{__tcp_template}', re.M)
        self.re_apache_jserv = re.compile(rf'^8009{__tcp_template}', re.M)
        self.re_influxdb = re.compile(rf'^8086{__tcp_template}', re.M)
        self.re_bitcoin = re.compile(rf'^(?:8333|18333|18444|38333){__tcp_template}', re.M)
        self.re_apache_casandra = re.compile(rf'^(?:9042|9160){__tcp_template}', re.M)
        self.re_raw_printing = re.compile(rf'^9100{__tcp_template}', re.M)
        self.re_elastic_search = re.compile(rf'^9200{__tcp_template}', re.M)
        self.re_ndmp = re.compile(rf'^10000{__tcp_template}', re.M)
        self.re_memcache = re.compile(rf'^11210{__tcp_template}', re.M)
        self.re_gluster_fs = re.compile(rf'^(?:24007|24008|24009|49152){__tcp_template}', re.M)
        self.re_mongo_db = re.compile(rf'^(?:27017|27018){__tcp_template}', re.M)
        self.re_hadoop = re.compile(rf'^(?:50030|50060|50070|50075|50090){__tcp_template}', re.M)

        # Compile UDP port regex #
        self.re_dhcp = re.compile(rf'^67{__udp_template}', re.M)
        self.re_tftp = re.compile(rf'^69{__udp_template}', re.M)
        self.re_ruserd = re.compile(rf'^1026{__udp_template}', re.M)
        self.re_ws_discovery = re.compile(rf'^3702{__udp_template}', re.M)
        self.re_mdns = re.compile(rf'^5353{__udp_template}', re.M)
        self.re_bacnet = re.compile(rf'^47808{__udp_template}', re.M)

        # Compile TCP/UDP port regex #
        self.re_dns = re.compile(rf'^53{__both_template}', re.M)
        self.re_kerberos = re.compile(rf'^88{__both_template}', re.M)
        self.re_rpc = re.compile(rf'^111{__both_template}', re.M)
        self.re_ntp = re.compile(rf'^123{__both_template}', re.M)
        self.re_msrpc = re.compile(rf'^135{__both_template}', re.M)
        self.re_netbios = re.compile(rf'^(?:137|138|139){__both_template}', re.M)
        self.re_snmp = re.compile(rf'^(?:161|162|10161|10162){__both_template}', re.M)
        self.re_irc = re.compile(rf'^(?:194|529|6667){__both_template}', re.M)
        self.re_ldap = re.compile(rf'^(?:389|636|3268|3269){__both_template}', re.M)
        self.re_ipsec_ike_vpn = re.compile(rf'^(?:500|1723){__both_template}', re.M)
        self.re_ipmi = re.compile(rf'^623{__both_template}', re.M)
        self.re_socks_proxy = re.compile(rf'^1080{__both_template}', re.M)
        self.re_nfs = re.compile(rf'^2049{__both_template}', re.M)
        self.re_rabbit_mq = re.compile(rf'^(?:5671|5672){__both_template}', re.M)
        self.re_couchdb = re.compile(rf'^(?:5984|6984){__both_template}', re.M)
        self.re_ethernet_ip = re.compile(rf'^44818{__both_template}', re.M)

    def scan_parse(self, scan_output: str) -> dict:
        """
        Takes the nmap scan output and performs regex matches to identify open ports.
        The result is returned in a dictionary with mapped comma separated ports.

        :param scan_output:  The nmap scan output that is passed in to matched with regex for
                             open ports.
        :return:  The mapped port number to regex match result dictionary.
        """
        return {
            # TCP port regex matches #
            '20,21': re.search(self.re_ftp, scan_output),
            '22': re.search(self.re_ssh, scan_output),
            '23': re.search(self.re_telnet, scan_output),
            '25,465,587,2525': re.search(self.re_smtp, scan_output),
            '43': re.search(self.re_whois, scan_output),
            '79': re.search(self.re_finger, scan_output),
            '80,443,8080,8443': re.search(self.re_web, scan_output),
            '110,995': re.search(self.re_pop3, scan_output),
            '113': re.search(self.re_ident, scan_output),
            '119,433': re.search(self.re_nntp, scan_output),
            '143,993': re.search(self.re_imap, scan_output),
            '199': re.search(self.re_smux, scan_output),
            '264': re.search(self.re_checkpoint_firewall, scan_output),
            '445': re.search(self.re_smb, scan_output),
            '502': re.search(self.re_modbus, scan_output),
            '513': re.search(self. re_rlogin, scan_output),
            '514': re.search(self.re_rsh, scan_output),
            '548': re.search(self.re_apple_filing, scan_output),
            '554': re.search(self.re_rtsp, scan_output),
            '631': re.search(self.re_cups, scan_output),
            '749': re.search(self.re_kerbv5_admin_tcp, scan_output),
            '761': re.search(self.re_kerbv4_passwd_tcp, scan_output),
            '873': re.search(self.re_rsync, scan_output),
            '1050,1098,1099': re.search(self.re_java_rmi, scan_output),
            '1433': re.search(self.re_mssql, scan_output),
            '1521': re.search(self.re_oracle_db, scan_output),
            '2100': re.search(self.re_oracle_xmldb, scan_output),
            '2375,2376': re.search(self.re_docker, scan_output),
            '3128': re.search(self.re_squid, scan_output),
            '3260': re.search(self.re_iscsi, scan_output),
            '3299': re.search(self.re_sap_router, scan_output),
            '3306': re.search(self.re_sql, scan_output),
            '3389': re.search(self.re_rdp, scan_output),
            '3632': re.search(self.re_distcc, scan_output),
            '3690': re.search(self.re_subversion, scan_output),
            '4369': re.search(self.re_epmd, scan_output),
            '4786': re.search(self.re_cisco_smart_install, scan_output),
            '5432,5433': re.search(self.re_postgresql, scan_output),
            '5439': re.search(self.re_redshift, scan_output),
            '5800,5900': re.search(self.re_vnc, scan_output),
            '5985,5986': re.search(self.re_winrm, scan_output),
            '6000': re.search(self.re_x11, scan_output),
            '6379': re.search(self.re_redis, scan_output),
            '8009': re.search(self.re_apache_jserv, scan_output),
            '8086': re.search(self.re_influxdb, scan_output),
            '8333,18333,18444,38333': re.search(self.re_bitcoin, scan_output),
            '9042,9160': re.search(self.re_apache_casandra, scan_output),
            '9100': re.search(self.re_raw_printing, scan_output),
            '9200': re.search(self.re_elastic_search, scan_output),
            '10000': re.search(self.re_ndmp, scan_output),
            '11210': re.search(self.re_memcache, scan_output),
            '24007,24008,24009,49152': re.search(self.re_gluster_fs, scan_output),
            '27017,27018': re.search(self.re_mongo_db, scan_output),
            '50030,50060,50070,50075,50090': re.search(self.re_hadoop, scan_output),

            # UDP port regex matches #
            '67': re.search(self.re_dhcp, scan_output),
            '69': re.search(self.re_tftp, scan_output),
            '1026': re.search(self.re_ruserd, scan_output),
            '3702': re.search(self.re_ws_discovery, scan_output),
            '5353': re.search(self.re_mdns, scan_output),
            '47808': re.search(self.re_bacnet, scan_output),

            # TCP/UDP port regex matches #
            '53': re.search(self.re_dns, scan_output),
            '88': re.search(self.re_kerberos, scan_output),
            '111': re.search(self.re_rpc, scan_output),
            '123': re.search(self.re_ntp, scan_output),
            '135': re.search(self.re_msrpc, scan_output),
            '137,138,139': re.search(self.re_netbios, scan_output),
            '161,162,10161,10162': re.search(self.re_snmp, scan_output),
            '194,529,6667': re.search(self.re_irc, scan_output),
            '389,636,3268,3269': re.search(self.re_ldap, scan_output),
            '500,1723': re.search(self.re_ipsec_ike_vpn, scan_output),
            '623': re.search(self.re_ipmi, scan_output),
            '1080': re.search(self.re_socks_proxy, scan_output),
            '2049': re.search(self.re_nfs, scan_output),
            '5671,5672': re.search(self.re_rabbit_mq, scan_output),
            '5984,6984': re.search(self.re_couchdb, scan_output),
            '44818': re.search(self.re_ethernet_ip, scan_output)
        }


class ScanConfig:
    # TODO: add validation routines for parsing methods and docstrings
    def __init__(self):
        self.name = None
        self.hosts = None
        self.time = None

    def parse_client(self, org_name: str):
        self.name = org_name

    def parse_hosts(self, host_list: list):
        self.hosts = host_list

    def parse_time(self, exec_time: str):
        self.time = exec_time


class ScanData:
    """
    Acts as storage class for data that is passed in to the async scanner event.
    """
    name = None
    ip_addr = None
    domain = None
    time = None
    out_path = None


async def service_handler(conf_obj: object, reg_obj: object, commands: list, custom_commands: list,
                          out_path: Path, cmd_args: list):
    """
    Takes passed in service information and executes commands parsed from yaml config file.

    :param conf_obj:  The program configuration instance.
    :param reg_obj:  The compiled regex instance.
    :param commands:  The commands to be executed that are based off the system path.
    :param custom_commands:  The commands to be executed that are based off custom program dir.
    :param out_path:  The path to the file where the output will be stored.
    :param cmd_args:  The cmd args to parsed in command (required: ip,domain,port; optional: proto)
    :return:  Nothing
    """
    # Iterate through ftp commands from yaml file #
    for command in commands + custom_commands:
        # If the command is based on system path #
        if command not in custom_commands:
            custom = False
        # If the command is a program in set CustomPrograms folder #
        else:
            custom = True

        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in conf_obj.delimiters]
        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = await cmd_parser(command, reg_obj, *cmd_args)

        # If the command syntax is missing #
        if not command:
            # Print and log error, then re-iterate to next command #
            print_err(f'Service handler for {out_path.name} attempted blank command')
            logging.error('Service handler for %s attempted blank command', out_path.name)
            continue

        # Split command into list to grab name #
        cmd_list = command.split()
        print(f'[+] Executing {cmd_list[0]} on {cmd_args[0]}')

        # If the command is based on system path #
        if not custom:
            # Execute system command #
            output = await async_proc_exec(command, conf_obj)
        # If the command is a program in set CustomPrograms folder #
        else:
            # Execute program/script in CustomPrograms folder #
            output = await async_proc_exec(command, conf_obj, is_custom=True)

        # If command exists and the command return data #
        if output:
            # Format and write the output with command title to service file #
            data = (f'>> {command}\n{"*" * (len(command) + 4)}\n'
                    f'{output.decode(errors="replace")}\n\n\n')
            await async_file_handler(out_path, 'a', data=data)


async def syntax_parse(parsed_cmd: str, yaml_syntax: str, delimiter: str, arg) -> str:
    """
    Parses in value of delimiter where it is placed in command syntax string.

    :param parsed_cmd:  The parsed command string buffer.
    :param yaml_syntax:  The command syntax parsed from YAML command configuration file.
    :param delimiter:  The string delimiter in command syntax where arg value is to be parsed.
    :param arg:  The string arg to be parsed into command syntax string.
    :return:  The parsed command syntax string ready to execute.
    """
    # If the command has yet to be parsed #
    if not parsed_cmd:
        # Replace the delimiter with passed in arg #
        parsed_cmd = yaml_syntax.replace(delimiter, arg)
    # If the command has already had and a delimiter parsed #
    else:
        # Replace the delimiter with passed in arg #
        parsed_cmd = parsed_cmd.replace(delimiter, arg)

    return parsed_cmd
