""" Built-in modules """
import errno
import logging
import re
import shlex
import sys
from pathlib import Path
from subprocess import Popen, CalledProcessError, SubprocessError, TimeoutExpired


class CompiledRegex:
    """
    Class object to store compiled regex patterns.
    """
    # Set templates for repetitive text in patterns #
    tcp_template = r'/tcp {2,6}open'
    udp_template = r'/udp {2,6}open'
    both_template = r'/(?:tcp|udp) {2,6}open'

    ''' Compile TCP port regex '''
    re_ftp = re.compile(rf'(?:20|21){tcp_template}')
    re_ssh = re.compile(rf'22{tcp_template}')
    re_telnet = re.compile(rf'23{tcp_template}')
    re_smtp = re.compile(rf'(?:25|465|587|2525){tcp_template}')
    re_finger = re.compile(rf'79{tcp_template}')
    re_web = re.compile(rf'(?:80|443|8080|8443){tcp_template}')
    re_pop3 = re.compile(rf'(?:110|995){tcp_template}')
    re_nntp = re.compile(rf'(?:119|443){tcp_template}')
    re_imap = re.compile(rf'(?:143|993){tcp_template}')
    re_smux = re.compile(rf'199{tcp_template}')
    re_smb = re.compile(rf'445{tcp_template}')
    re_rtsp = re.compile(rf'554{tcp_template}')
    re_cups = re.compile(rf'631{tcp_template}')
    re_kerbv5_passwd_tcp = re.compile(rf'749{tcp_template}')
    re_kerbv4_passwd_tcp = re.compile(rf'761{tcp_template}')
    re_rsync = re.compile(rf'873{tcp_template}')
    re_iis = re.compile(rf'1025{tcp_template}')
    re_mssql = re.compile(rf'1433{tcp_template}')
    re_oracle_db = re.compile(rf'1521{tcp_template}')
    re_oracle_xmldb = re.compile(rf'2100{tcp_template}')
    re_sql = re.compile(rf'3306{tcp_template}')
    re_oracle_web = re.compile(rf'3339{tcp_template}')
    re_rdp = re.compile(rf'3389{tcp_template}')
    re_adb = re.compile(rf'(?:5037|5555){tcp_template}')
    re_vnc = re.compile(rf'(?:5800|5900){tcp_template}')
    re_winrm = re.compile(rf'(?:5985|5986){tcp_template}')
    re_ad_admin = re.compile(rf'9389{tcp_template}')

    ''' Compile UDP port regex '''
    re_dhcp = re.compile(rf'67{udp_template}')
    re_tftp = re.compile(rf'69{udp_template}')
    re_kerbv5_passwd_udp = re.compile(rf'464{udp_template}')
    re_kerbv5_ticket_conv_udp = re.compile(rf'4444{udp_template}')
    re_mdns = re.compile(rf'5353{udp_template}')

    ''' Compile TCP/UDP port regex '''
    re_wins = re.compile(rf'42{both_template}')
    re_dns = re.compile(rf'53{both_template}')
    re_kerbv5_ticket = re.compile(rf'88{both_template}')
    re_rpc = re.compile(rf'111{both_template}')
    re_ntp = re.compile(rf'123{both_template}')
    re_msrpc = re.compile(rf'135{both_template}')
    re_netbios_name = re.compile(rf'137{both_template}')
    re_netbios_sesh = re.compile(rf'139{both_template}')
    re_snmp = re.compile(rf'(?:161|162|10161|10162){both_template}')
    re_ldap = re.compile(rf'(?:389|636){both_template}')
    re_kerbv4_ticket = re.compile(rf'750{both_template}')
    re_kerbv4_admin = re.compile(rf'751{both_template}')
    re_windomain_indicator = re.compile(rf'(?:1030|1032|1033|1038){both_template}')
    re_oracle_agent = re.compile(rf'(?:1748|1754|1808|1809){both_template}')
    re_nfs = re.compile(rf'2049{both_template}')
    re_globalcat_ldap = re.compile(rf'(?:3268|3269){both_template}')
    re_upnotifyp = re.compile(rf'4445{both_template}')
    re_rsip = re.compile(rf'4555{both_template}')
    re_wsdapi = re.compile(rf'5357{both_template}')
    re_dfsr = re.compile(rf'5722{both_template}')
    re_wrms = re.compile(rf'47001{both_template}')

def error_query(err_path: str, err_mode: str, err_obj: object):
    """
    Looks up the errno message to get description.

    :param err_path:  The path to the file where error occurred.
    :param err_mode:  The file mode used during error.
    :param err_obj:  The error instance passed in from occurrence.
    :return:  Nothing
    """
    # If file does not exist #
    if err_obj.errno == errno.ENOENT:
        print_err(f'{err_path} does not exist')
        logging.exception('%s does not exist\n\n', err_path)
        sys.exit(2)

    # If the file does not have read/write access #
    elif err_obj.errno == errno.EPERM:
        print_err(f'{err_path} does not have permissions for {err_mode} file mode, if file exists '
                 'confirm it is closed')
        logging.exception('%s does not have permissions for %s file mode\n\n', err_path, err_mode)
        sys.exit(3)

    # File IO error occurred #
    elif err_obj.errno == errno.EIO:
        print_err(f'IO error occurred during {err_mode} mode on {err_path}')
        logging.exception(f'IO error occurred during %s mode on %s\n\n', err_mode, err_path)
        sys.exit(4)

    # If other unexpected file operation occurs #
    else:
        print_err(f'Unexpected file operation occurred accessing {err_path}: {err_obj.errno}')
        logging.exception('Unexpected file operation occurred accessing %s: %s\n\n', err_path,
                          err_obj.errno)
        sys.exit(5)


def file_handler(file_path: Path, mode: str, data=None) -> str | None:
    """
    Read/Write file operation handler.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to performed on file.
    :param data:  Optional data param for writing data to file.
    :return:  Read data on read or None for write.
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                return file.read()
            # If file mode is write operation #
            else:
                # If there is no data to write #
                if not data:
                    # Print error, log, and exit #
                    print_err(f'Attempting to write to {file_path.name} with no data')
                    logging.error('Attempting to write to %s with no data\n\n', file_path.name)
                    sys.exit(6)

                file.write(data)

            # Not necessary but follows pylint return all or nothing rule #
            return None

    # If error occurs during file operation #
    except (IOError, OSError) as err:
        # Look up file error based on low-level descriptor #
        error_query(str(file_path.resolve()), mode, err)


def print_err(msg: str):
    """
    Displays the error message through stderr (standard error).

    :param msg:  The error message to be displayed.
    :return:  Nothing
    """
    print(f'\n* [ERROR] {msg} *\n', file=sys.stderr)


class ProgramPaths:
    """
    Class object to store paths associated with program operations.
    """
    # Establish program paths #
    cwd = Path.cwd()
    out_dir = cwd / 'Output'
    exploit_dir = out_dir / 'Exploits'
    loot_dir = out_dir / 'Loot'
    report_dir = out_dir / 'Reports'
    pic_dir = report_dir / 'Screenshots'
    scan_dir = out_dir / 'ScanOutput'
    log_file = cwd / 'pentester_automater.log'


def system_cmd(cmd: str, stdout, stderr, exec_time: int, out_file=None):
    """
    Executes shell-escaped system command with the ability to redirect output to a file for
    generating scan reports.

    :param cmd:  The command to be executed.
    :param stdout:  The child process standard output.
    :param stderr:  The child process standard error.
    :param exec_time:  The execution timeout to prevent process hangs.
    :param out_file:  The output file where the results are stored.
    :return:  Nothing
    """
    # Shell escape command string #
    exe = shlex.quote(cmd)
    command = None

    try:
        # If the output is to be written to a file #
        if out_file:
            # Create output file in write mode #
            with open(out_file, 'w') as file:
                # TODO use the log file as stderr
                command = Popen(exe, stdout=file, stderr=stderr, shell=False)
                command.communicate(timeout=exec_time)
        # If the command is executed without file redirect #
        else:
            command = Popen(exe, stdout=stdout, stderr=stderr, shell=False)
            command.communicate(timeout=exec_time)

    # If error occurs during file operation #
    except (IOError, OSError) as file_err:
        error_query(str(out_file.resolve()), 'w', file_err)

    # Handles process timeouts and errors #
    except (SubprocessError, TimeoutExpired, CalledProcessError, OSError, ValueError) as proc_err:
        command.kill()
        command.communicate()

        # If error is of significance (non-timeout) #
        if not TimeoutExpired:
            print_err(f'Error occurred during child process execution: {proc_err}')
            logging.exception('Error occurred during child process execution: %s\n\n', proc_err)
            sys.exit(7)
