""" Built-in modules """
import errno
import logging
import re
import shlex
import sys
from pathlib import Path
from subprocess import Popen, CalledProcessError, SubprocessError, TimeoutExpired
# External modules #
from yaml import safe_load_all


class CompiledRegex:
    """
    Class object to store compiled regex patterns.
    """
    # Set template private variables for repetitive text in patterns #
    __tcp_template = r'/tcp {2,6}open'
    __udp_template = r'/udp {2,6}open'
    __both_template = r'/(?:tcp|udp) {2,6}open'

    # Compile TCP port regex #
    re_ftp = re.compile(rf'(?:20|21){__tcp_template}')
    re_ssh = re.compile(rf'22{__tcp_template}')
    re_telnet = re.compile(rf'23{__tcp_template}')
    re_smtp = re.compile(rf'(?:25|465|587|2525){__tcp_template}')
    re_finger = re.compile(rf'79{__tcp_template}')
    re_web = re.compile(rf'(?:80|443|8080|8443){__tcp_template}')
    re_pop3 = re.compile(rf'(?:110|995){__tcp_template}')
    re_nntp = re.compile(rf'(?:119|443){__tcp_template}')
    re_imap = re.compile(rf'(?:143|993){__tcp_template}')
    re_smux = re.compile(rf'199{__tcp_template}')
    re_smb = re.compile(rf'445{__tcp_template}')
    re_rtsp = re.compile(rf'554{__tcp_template}')
    re_cups = re.compile(rf'631{__tcp_template}')
    re_kerbv5_admin_tcp = re.compile(rf'749{__tcp_template}')
    re_kerbv4_passwd_tcp = re.compile(rf'761{__tcp_template}')
    re_rsync = re.compile(rf'873{__tcp_template}')
    re_iis = re.compile(rf'1025{__tcp_template}')
    re_mssql = re.compile(rf'1433{__tcp_template}')
    re_oracle_db = re.compile(rf'1521{__tcp_template}')
    re_oracle_xmldb = re.compile(rf'2100{__tcp_template}')
    re_sql = re.compile(rf'3306{__tcp_template}')
    re_oracle_web = re.compile(rf'3339{__tcp_template}')
    re_rdp = re.compile(rf'3389{__tcp_template}')
    re_adb = re.compile(rf'(?:5037|5555){__tcp_template}')
    re_vnc = re.compile(rf'(?:5800|5900){__tcp_template}')
    re_winrm = re.compile(rf'(?:5985|5986){__tcp_template}')
    re_ad_admin = re.compile(rf'9389{__tcp_template}')

    # Compile UDP port regex #
    re_dhcp = re.compile(rf'67{__udp_template}')
    re_tftp = re.compile(rf'69{__udp_template}')
    re_kerbv5_passwd_udp = re.compile(rf'464{__udp_template}')
    re_kerbv5_ticket_udp = re.compile(rf'4444{__udp_template}')
    re_mdns = re.compile(rf'5353{__udp_template}')

    # Compile TCP/UDP port regex #
    re_wins = re.compile(rf'42{__both_template}')
    re_dns = re.compile(rf'53{__both_template}')
    re_kerbv5_ticket = re.compile(rf'88{__both_template}')
    re_rpc = re.compile(rf'111{__both_template}')
    re_ntp = re.compile(rf'123{__both_template}')
    re_msrpc = re.compile(rf'135{__both_template}')
    re_netbios_name = re.compile(rf'137{__both_template}')
    re_netbios_sesh = re.compile(rf'139{__both_template}')
    re_snmp = re.compile(rf'(?:161|162|10161|10162){__both_template}')
    re_ldap = re.compile(rf'(?:389|636){__both_template}')
    re_kerbv4_ticket = re.compile(rf'750{__both_template}')
    re_kerbv4_admin = re.compile(rf'751{__both_template}')
    re_windomain_indicator = re.compile(rf'(?:1030|1032|1033|1038){__both_template}')
    re_oracle_agent = re.compile(rf'(?:1748|1754|1808|1809){__both_template}')
    re_nfs = re.compile(rf'2049{__both_template}')
    re_globalcat_ldap = re.compile(rf'(?:3268|3269){__both_template}')
    re_upnotifyp = re.compile(rf'4445{__both_template}')
    re_rsip = re.compile(rf'4555{__both_template}')
    re_wsdapi = re.compile(rf'5357{__both_template}')
    re_dfsr = re.compile(rf'5722{__both_template}')
    re_wrms = re.compile(rf'47001{__both_template}')


class ConfigClass:
    """
    Class to store yaml file configurations that are referenced throughout operations.

    :param yaml_data:  Dict data from yaml file to be parsed into config class.
    """
    def __init__(self, yaml_data: dict):
        # Program initialization variables #
        self.min_cores = yaml_data['init']['min_cores']
        self.hosts = yaml_data['init']['hosts']
        self.cidr = yaml_data['init']['cidr']
        self.ports = yaml_data['init']['ports']
        self.nmap = yaml_data['init']['nmap']

        # TCP based port commands #
        self.ftp = yaml_data['ftp']['commands']
        self.ssh = yaml_data['ssh']['commands']
        self.telnet = yaml_data['telnet']['commands']
        self.smtp = yaml_data['smtp']['commands']
        self.finger = yaml_data['finger']['commands']
        self.web = yaml_data['web']['commands']
        self.pop3 = yaml_data['pop3']['commands']
        self.nntp = yaml_data['nntp']['commands']
        self.imap = yaml_data['imap']['commands']
        self.snux = yaml_data['snux']['commands']
        self.smb = yaml_data['smb']['commands']
        self.rtsp = yaml_data['rtsp']['commands']
        self.cups = yaml_data['cups']['commands']
        self.kerberos_v5_admin_tcp = yaml_data['kerberos_v5_admin_tcp']['commands']
        self.kerberos_v4_passwd_tcp = yaml_data['kerberos_v4_passwd_tcp']['commands']
        self.rsync = yaml_data['rsync']['commands']
        self.iis = yaml_data['iis']['commands']
        self.mssql = yaml_data['mssql']['commands']
        self.oracle_db = yaml_data['oracle_db']['commands']
        self.oracle_xml_db = yaml_data['oracle_xml_db']['commands']
        self.sql = yaml_data['sql']['commands']
        self.oracle_web = yaml_data['oracle_web']['commands']
        self.rdp = yaml_data['rdp']['commands']
        self.adb = yaml_data['adb']['commands']
        self.vnc = yaml_data['vnc']['commands']
        self.winrm = yaml_data['winrm']['commands']
        self.adac = yaml_data['adac']['commands']

        # UDP based port commands #
        self.dhcp = yaml_data['dhcp']['commands']
        self.tftp = yaml_data['tftp']['commands']
        self.kerberos_v5_passwd_udp = yaml_data['kerberos_v5_passwd_udp']['commands']
        self.kerberos_v5_ticket_udp = yaml_data['keberos_v5_ticket_udp']['commands']
        self.mdns = yaml_data['mdns']['commands']

        # TCP/UDP based port commands #
        self.wins = yaml_data['wins']['commands']
        self.dns = yaml_data['dns']['commands']
        self.kerberos_v5_ticket = yaml_data['kerberos_v5_ticket']['commands']
        self.rpc = yaml_data['rpc']['commands']
        self.ntp = yaml_data['ntp']['commands']
        self.msrpc = yaml_data['msrpc']['commands']
        self.netbios_name = yaml_data['netbios_name']['commands']
        self.netbios_sesh = yaml_data['netbios_sesh']['commands']
        self.snmp = yaml_data['snmp']['commands']
        self.ldap = yaml_data['ldap']['commands']
        self.kerberos_v4_ticket = yaml_data['kerberos_v4_ticket']['commands']
        self.kerberos_v4_admin = yaml_data['kerberos_v4_admin']['commands']
        self.windomain_indicator = yaml_data['windomain_indicator']['commands']
        self.oracle_agent = yaml_data['oracle_agent']['commands']
        self.nfs = yaml_data['nfs']['commands']
        self.globalcat_ldap = yaml_data['globalcat_ldap']['commands']
        self.upnotifyp = yaml_data['upnotifyp']['commands']
        self.rsip = yaml_data['rsip']['commands']
        self.wsdapi = yaml_data['wsdapi']['commands']
        self.dfsr = yaml_data['dfsr']['commands']
        self.wrms = yaml_data['wrms']['commands']


def config_input(base_path: Path) -> Path:
    """
    Prompts user for yaml configuration to use for scan automation.

    :param base_path:  The base path to the current working directory.
    :return:  Validated configuration file path to be used for scans.
    """
    while True:
        # Gather user input to specify what config file to use #
        file_name = input('[+] Please enter the name of the config file to use: ')
        # Format path with input config file name #
        file_path = base_path / 'Configs' / file_name

        # If the input file does not exist or is not a yaml config file #
        if not file_path.exists() or not str(file_path).endswith('yml'):
            # Print error and re-iterate #
            print_err('Input file path does not exist .. try again')
            continue

        return file_path


def error_query(err_path: str, err_mode: str, err_obj: object):
    """
    Looks up the errno message to get description.

    :param err_path:  The path to the file where error occurred.
    :param err_mode:  The file mode used during error.
    :param err_obj:  The error instance passed in from occurrence.
    :return:  Nothing
    """
    # If file does not exist #
    if err_obj.errno == errno.ENOENT:
        print_err(f'{err_path} does not exist')
        logging.exception('%s does not exist\n\n', err_path)
        sys.exit(2)

    # If the file does not have read/write access #
    elif err_obj.errno == errno.EPERM:
        print_err(f'{err_path} does not have permissions for {err_mode} file mode, if file exists '
                 'confirm it is closed')
        logging.exception('%s does not have permissions for %s file mode\n\n', err_path, err_mode)
        sys.exit(3)

    # File IO error occurred #
    elif err_obj.errno == errno.EIO:
        print_err(f'IO error occurred during {err_mode} mode on {err_path}')
        logging.exception(f'IO error occurred during %s mode on %s\n\n', err_mode, err_path)
        sys.exit(4)

    # If other unexpected file operation occurs #
    else:
        print_err(f'Unexpected file operation occurred accessing {err_path}: {err_obj.errno}')
        logging.exception('Unexpected file operation occurred accessing %s: %s\n\n', err_path,
                          err_obj.errno)
        sys.exit(5)


def file_handler(file_path: Path, mode: str, data=None, yaml=False) -> str | None:
    """
    Read/Write file operation handler for text and yaml file formats.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to performed on file.
    :param data:  Kwarg data param for writing data to file.
    :param yaml:  Kwarg boolean operator to handle yaml configuration files.
    :return:  Read string data on read or None for write.
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                # If the file is text format #
                if not yaml:
                    # Return text data #
                    return file.read()
                # If the file is YAML format #
                else:
                    # Return Safe loaded YAML data #
                    return safe_load_all(file)

            # If file mode is write operation #
            else:
                # If there is no data to write #
                if not data:
                    # Print error, log, and exit #
                    print_err(f'Attempting to write to {file_path.name} with no data')
                    logging.error('Attempting to write to %s with no data\n\n', file_path.name)
                    sys.exit(6)

                # If attempting to overwrite yaml config file #
                if yaml:
                    # Print error, log, and exit #
                    print_err('Attempted to write to YAML configuration file')
                    logging.error('Attempted to write to YAML configuration file')
                    sys.exit(7)

                file.write(data)

            # Follows pylint return all or nothing rule #
            return None

    # If error occurs during file operation #
    except (IOError, OSError) as err:
        # Look up file error based on low-level descriptor #
        error_query(str(file_path.resolve()), mode, err)


def print_err(msg: str):
    """
    Displays the error message through stderr (standard error).

    :param msg:  The error message to be displayed.
    :return:  Nothing
    """
    print(f'\n* [ERROR] {msg} *\n', file=sys.stderr)


def system_cmd(cmd: str, stdout, stderr, exec_time: int, out_file=None):
    """
    Executes shell-escaped system command with the ability to redirect output to a file for
    generating scan reports.

    :param cmd:  The command to be executed.
    :param stdout:  The child process standard output.
    :param stderr:  The child process standard error.
    :param exec_time:  The execution timeout to prevent process hangs.
    :param out_file:  The output file where the results are stored.
    :return:  Nothing
    """
    # Shell escape command string #
    exe = shlex.quote(cmd)
    command = None

    try:
        # If the output is to be written to a file #
        if out_file:
            # Create output file in write mode #
            with open(out_file, 'w') as file:
                # TODO use the log file as stderr
                command = Popen(exe, stdout=file, stderr=stderr, shell=False)
                command.communicate(timeout=exec_time)
        # If the command is executed without file redirect #
        else:
            command = Popen(exe, stdout=stdout, stderr=stderr, shell=False)
            command.communicate(timeout=exec_time)

    # If error occurs during file operation #
    except (IOError, OSError) as file_err:
        error_query(str(out_file.resolve()), 'w', file_err)

    # Handles process timeouts and errors #
    except (SubprocessError, TimeoutExpired, CalledProcessError, OSError, ValueError) as proc_err:
        command.kill()
        command.communicate()

        # If error is of significance (non-timeout) #
        if not TimeoutExpired:
            print_err(f'Error occurred during child process execution: {proc_err}')
            logging.exception('Error occurred during child process execution: %s\n\n', proc_err)
            sys.exit(7)
