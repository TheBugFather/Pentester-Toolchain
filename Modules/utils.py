""" Built-in modules """
import errno
import logging
import re
import shlex
import sys
from pathlib import Path
from subprocess import Popen, CalledProcessError, SubprocessError, TimeoutExpired
# External modules #
from yaml import safe_load_all
# Custom Modules #
from Modules.tcp_handlers import ftp_handler, ssh_handler, telnet_handler, smtp_handler, \
                                 finger_handler, web_handler, pop3_handler, nntp_handler, \
                                 imap_handler, smux_handler, smb_handler, rtsp_handler, \
                                 cups_handler, kerbv5_admin_tcp_handler, kerbv4_passwd_tcp_handler,\
                                 rsync_handler, iis_handler, mssql_handler, oracle_db_handler, \
                                 oracle_xmldb_handler, sql_handler, oracle_web_handler, \
                                 rdp_handler, adb_handler, vnc_handler, winrm_handler, \
                                 ad_admin_handler
from Modules.tcp_udp_handlers import wins_handler, dns_handler, kerbv5_ticket_handler, \
                                     rpc_handler, ntp_handler, msrpc_handler, \
                                     netbios_name_handler, netbios_sesh_handler, snmp_handler, \
                                     ldap_handler, kerbv4_ticket_handler, kerbv4_admin_handler, \
                                     windomain_handler, oracle_agent_handler, nfs_handler, \
                                     globalcat_ldap_handler, upnotifyp_handler, rsip_handler, \
                                     wsdapi_handler, dfsr_handler, wrms_handler
from Modules.udp_handlers import dhcp_handler, tftp_handler, kerbv5_passwd_udp_handler, \
                                 kerbv5_ticket_udp_handler, mdns_handler


class RegexHandler:
    """
    Class object to store compiled regex patterns.
    """
    def __init__(self):
        # Set template private variables for repetitive text in patterns #
        __tcp_template = r'/tcp {2,6}open'
        __udp_template = r'/udp {2,6}open'
        __both_template = r'/(?:tcp|udp) {2,6}open'

        # Compile misc regex #
        self.re_ip = r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
        self.re_cidr = r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2})'

        # Compile TCP port regex #
        self.re_ftp = re.compile(rf'(?:20|21){__tcp_template}')
        self.re_ssh = re.compile(rf'22{__tcp_template}')
        self.re_telnet = re.compile(rf'23{__tcp_template}')
        self.re_smtp = re.compile(rf'(?:25|465|587|2525){__tcp_template}')
        self.re_finger = re.compile(rf'79{__tcp_template}')
        self.re_web = re.compile(rf'(?:80|443|8080|8443){__tcp_template}')
        self.re_pop3 = re.compile(rf'(?:110|995){__tcp_template}')
        self.re_nntp = re.compile(rf'(?:119|433){__tcp_template}')
        self.re_imap = re.compile(rf'(?:143|993){__tcp_template}')
        self.re_smux = re.compile(rf'199{__tcp_template}')
        self.re_smb = re.compile(rf'445{__tcp_template}')
        self.re_rtsp = re.compile(rf'554{__tcp_template}')
        self.re_cups = re.compile(rf'631{__tcp_template}')
        self.re_kerbv5_admin_tcp = re.compile(rf'749{__tcp_template}')
        self.re_kerbv4_passwd_tcp = re.compile(rf'761{__tcp_template}')
        self.re_rsync = re.compile(rf'873{__tcp_template}')
        self.re_iis = re.compile(rf'1025{__tcp_template}')
        self.re_mssql = re.compile(rf'1433{__tcp_template}')
        self.re_oracle_db = re.compile(rf'1521{__tcp_template}')
        self.re_oracle_xmldb = re.compile(rf'2100{__tcp_template}')
        self.re_sql = re.compile(rf'3306{__tcp_template}')
        self.re_oracle_web = re.compile(rf'3339{__tcp_template}')
        self.re_rdp = re.compile(rf'3389{__tcp_template}')
        self.re_adb = re.compile(rf'(?:5037|5555){__tcp_template}')
        self.re_vnc = re.compile(rf'(?:5800|5900){__tcp_template}')
        self.re_winrm = re.compile(rf'(?:5985|5986){__tcp_template}')
        self.re_ad_admin = re.compile(rf'9389{__tcp_template}')

        # Compile UDP port regex #
        self.re_dhcp = re.compile(rf'67{__udp_template}')
        self.re_tftp = re.compile(rf'69{__udp_template}')
        self.re_kerbv5_passwd_udp = re.compile(rf'464{__udp_template}')
        self.re_kerbv5_ticket_udp = re.compile(rf'4444{__udp_template}')
        self.re_mdns = re.compile(rf'5353{__udp_template}')

        # Compile TCP/UDP port regex #
        self.re_wins = re.compile(rf'42{__both_template}')
        self.re_dns = re.compile(rf'53{__both_template}')
        self.re_kerbv5_ticket = re.compile(rf'88{__both_template}')
        self.re_rpc = re.compile(rf'111{__both_template}')
        self.re_ntp = re.compile(rf'123{__both_template}')
        self.re_msrpc = re.compile(rf'135{__both_template}')
        self.re_netbios_name = re.compile(rf'137{__both_template}')
        self.re_netbios_sesh = re.compile(rf'139{__both_template}')
        self.re_snmp = re.compile(rf'(?:161|162|10161|10162){__both_template}')
        self.re_ldap = re.compile(rf'(?:389|636){__both_template}')
        self.re_kerbv4_ticket = re.compile(rf'750{__both_template}')
        self.re_kerbv4_admin = re.compile(rf'751{__both_template}')
        self.re_windomain_indicator = re.compile(rf'(?:1030|1032|1033|1038){__both_template}')
        self.re_oracle_agent = re.compile(rf'(?:1748|1754|1808|1809){__both_template}')
        self.re_nfs = re.compile(rf'2049{__both_template}')
        self.re_globalcat_ldap = re.compile(rf'(?:3268|3269){__both_template}')
        self.re_upnotifyp = re.compile(rf'4445{__both_template}')
        self.re_rsip = re.compile(rf'4555{__both_template}')
        self.re_wsdapi = re.compile(rf'5357{__both_template}')
        self.re_dfsr = re.compile(rf'5722{__both_template}')
        self.re_wrms = re.compile(rf'47001{__both_template}')

    def scan_parse(self, scan_output: str):
        return {
        # TCP port regex matches #
        '20,21': re.search(self.re_ftp, scan_output),
        '22': re.search(self.re_ssh, scan_output),
        '23': re.search(self.re_telnet, scan_output),
        '25,465,587,2525': re.search(self.re_smtp, scan_output),
        '79': re.search(self.re_finger, scan_output),
        '80,443,8080,8443': re.search(self.re_web, scan_output),
        '110,995': re.search(self.re_pop3, scan_output),
        '119,433': re.search(self.re_nntp, scan_output),
        '143,993': re.search(self.re_imap, scan_output),
        '199': re.search(self.re_smux, scan_output),
        '445': re.search(self.re_smb, scan_output),
        '554': re.search(self.re_rtsp, scan_output),
        '631': re.search(self.re_cups, scan_output),
        '749': re.search(self.re_kerbv5_admin_tcp, scan_output),
        '761': re.search(self.re_kerbv4_passwd_tcp, scan_output),
        '873': re.search(self.re_rsync, scan_output),
        '1025': re.search(self.re_iis, scan_output),
        '1433': re.search(self.re_mssql, scan_output),
        '1521': re.search(self.re_oracle_db, scan_output),
        '2100': re.search(self.re_oracle_xmldb, scan_output),
        '3306': re.search(self.re_sql, scan_output),
        '3339': re.search(self.re_oracle_web, scan_output),
        '3389': re.search(self.re_rdp, scan_output),
        '5037,5555': re.search(self.re_adb, scan_output),
        '5800,5900': re.search(self.re_vnc, scan_output),
        '5985,5986': re.search(self.re_winrm, scan_output),
        '9389': re.search(self.re_ad_admin, scan_output),

        # UDP port regex matches #
        '67': re.search(self.re_dhcp, scan_output),
        '69': re.search(self.re_tftp, scan_output),
        '464': re.search(self.re_kerbv5_passwd_udp, scan_output),
        '4444': re.search(self.re_kerbv5_ticket_udp, scan_output),
        '5353': re.search(self.re_mdns, scan_output),

        # TCP/UDP port regex matches #
        '42': re.search(self.re_wins, scan_output),
        '53': re.search(self.re_dns, scan_output),
        '88': re.search(self.re_kerbv5_ticket, scan_output),
        '111': re.search(self.re_rpc, scan_output),
        '123': re.search(self.re_ntp, scan_output),
        '135': re.search(self.re_msrpc, scan_output),
        '137': re.search(self.re_netbios_name, scan_output),
        '139': re.search(self.re_netbios_sesh, scan_output),
        '161,162,10161,10162': re.search(self.re_snmp, scan_output),
        '389,636': re.search(self.re_ldap, scan_output),
        '750': re.search(self.re_kerbv4_ticket, scan_output),
        '751': re.search(self.re_kerbv4_admin, scan_output),
        '1030,1032,1033,1038': re.search(self.re_windomain_indicator, scan_output),
        '1748,1754,1808,1809': re.search(self.re_oracle_agent, scan_output),
        '2049': re.search(self.re_nfs, scan_output),
        '3268,3269': re.search(self.re_globalcat_ldap, scan_output),
        '4445': re.search(self.re_upnotifyp, scan_output),
        '4555': re.search(self.re_rsip, scan_output),
        '5357': re.search(self.re_wsdapi, scan_output),
        '5722': re.search(self.re_dfsr, scan_output),
        '47001': re.search(self.re_wrms, scan_output)
        }


class ConfigClass:
    """
    Class to store yaml file configurations that are referenced throughout operations.

    :param yaml_data:  Dict data from yaml file to be parsed into config class.
    """
    def __init__(self, yaml_data: dict):
        # Program initialization variables #
        self.ping_threads = yaml_data['init']['ping_threads']
        self.min_cores = yaml_data['init']['min_cores']
        self.hosts = yaml_data['init']['hosts']
        self.cidr = yaml_data['init']['cidr']
        self.ports = yaml_data['init']['ports']
        self.port_scan = yaml_data['init']['port_scan']

        # TCP based port commands #
        self.ftp = yaml_data['ftp']['commands']
        self.ssh = yaml_data['ssh']['commands']
        self.telnet = yaml_data['telnet']['commands']
        self.smtp = yaml_data['smtp']['commands']
        self.finger = yaml_data['finger']['commands']
        self.web = yaml_data['web']['commands']
        self.pop3 = yaml_data['pop3']['commands']
        self.nntp = yaml_data['nntp']['commands']
        self.imap = yaml_data['imap']['commands']
        self.snux = yaml_data['snux']['commands']
        self.smb = yaml_data['smb']['commands']
        self.rtsp = yaml_data['rtsp']['commands']
        self.cups = yaml_data['cups']['commands']
        self.kerberos_v5_admin_tcp = yaml_data['kerberos_v5_admin_tcp']['commands']
        self.kerberos_v4_passwd_tcp = yaml_data['kerberos_v4_passwd_tcp']['commands']
        self.rsync = yaml_data['rsync']['commands']
        self.iis = yaml_data['iis']['commands']
        self.mssql = yaml_data['mssql']['commands']
        self.oracle_db = yaml_data['oracle_db']['commands']
        self.oracle_xml_db = yaml_data['oracle_xml_db']['commands']
        self.sql = yaml_data['sql']['commands']
        self.oracle_web = yaml_data['oracle_web']['commands']
        self.rdp = yaml_data['rdp']['commands']
        self.adb = yaml_data['adb']['commands']
        self.vnc = yaml_data['vnc']['commands']
        self.winrm = yaml_data['winrm']['commands']
        self.adac = yaml_data['adac']['commands']

        # UDP based port commands #
        self.dhcp = yaml_data['dhcp']['commands']
        self.tftp = yaml_data['tftp']['commands']
        self.kerberos_v5_passwd_udp = yaml_data['kerberos_v5_passwd_udp']['commands']
        self.kerberos_v5_ticket_udp = yaml_data['keberos_v5_ticket_udp']['commands']
        self.mdns = yaml_data['mdns']['commands']

        # TCP/UDP based port commands #
        self.wins = yaml_data['wins']['commands']
        self.dns = yaml_data['dns']['commands']
        self.kerberos_v5_ticket = yaml_data['kerberos_v5_ticket']['commands']
        self.rpc = yaml_data['rpc']['commands']
        self.ntp = yaml_data['ntp']['commands']
        self.msrpc = yaml_data['msrpc']['commands']
        self.netbios_name = yaml_data['netbios_name']['commands']
        self.netbios_sesh = yaml_data['netbios_sesh']['commands']
        self.snmp = yaml_data['snmp']['commands']
        self.ldap = yaml_data['ldap']['commands']
        self.kerberos_v4_ticket = yaml_data['kerberos_v4_ticket']['commands']
        self.kerberos_v4_admin = yaml_data['kerberos_v4_admin']['commands']
        self.windomain_indicator = yaml_data['windomain_indicator']['commands']
        self.oracle_agent = yaml_data['oracle_agent']['commands']
        self.nfs = yaml_data['nfs']['commands']
        self.globalcat_ldap = yaml_data['globalcat_ldap']['commands']
        self.upnotifyp = yaml_data['upnotifyp']['commands']
        self.rsip = yaml_data['rsip']['commands']
        self.wsdapi = yaml_data['wsdapi']['commands']
        self.dfsr = yaml_data['dfsr']['commands']
        self.wrms = yaml_data['wrms']['commands']


def config_input(base_path: Path) -> Path:
    """
    Prompts user for yaml configuration to use for scan automation.

    :param base_path:  The base path to the current working directory.
    :return:  Validated configuration file path to be used for scans.
    """
    while True:
        # Gather user input to specify what config file to use #
        file_name = input('[+] Please enter the name of the config file to use: ')
        # Format path with input config file name #
        file_path = base_path / 'Configs' / file_name

        # If the input file does not exist or is not a yaml config file #
        if not file_path.exists() or not str(file_path).endswith('yml'):
            # Print error and re-iterate #
            print_err('Input file path does not exist .. try again')
            continue

        return file_path


def error_query(err_path: str, err_mode: str, err_obj: object):
    """
    Looks up the errno message to get description.

    :param err_path:  The path to the file where error occurred.
    :param err_mode:  The file mode used during error.
    :param err_obj:  The error instance passed in from occurrence.
    :return:  Nothing
    """
    # If file does not exist #
    if err_obj.errno == errno.ENOENT:
        print_err(f'{err_path} does not exist')
        logging.exception('%s does not exist\n\n', err_path)
        sys.exit(2)

    # If the file does not have read/write access #
    elif err_obj.errno == errno.EPERM:
        print_err(f'{err_path} does not have permissions for {err_mode} file mode, if file exists '
                 'confirm it is closed')
        logging.exception('%s does not have permissions for %s file mode\n\n', err_path, err_mode)
        sys.exit(3)

    # File IO error occurred #
    elif err_obj.errno == errno.EIO:
        print_err(f'IO error occurred during {err_mode} mode on {err_path}')
        logging.exception(f'IO error occurred during %s mode on %s\n\n', err_mode, err_path)
        sys.exit(4)

    # If other unexpected file operation occurs #
    else:
        print_err(f'Unexpected file operation occurred accessing {err_path}: {err_obj.errno}')
        logging.exception('Unexpected file operation occurred accessing %s: %s\n\n', err_path,
                          err_obj.errno)
        sys.exit(5)


def file_handler(file_path: Path, mode: str, data=None, yaml=False) -> str | None:
    """
    Read/Write file operation handler for text and yaml file formats.

    :param file_path:  The path object to the file to perform IO operation.
    :param mode:  The IO operation mode to performed on file.
    :param data:  Kwarg data param for writing data to file.
    :param yaml:  Kwarg boolean operator to handle yaml configuration files.
    :return:  Read string data on read or None for write.
    """
    try:
        # Open the file in passed in mode #
        with file_path.open(mode) as file:
            # If file mode is read operation #
            if mode in ('r', 'rb'):
                # If the file is text format #
                if not yaml:
                    # Return text data #
                    return file.read()
                # If the file is YAML format #
                else:
                    # Return Safe loaded YAML data #
                    return safe_load_all(file)

            # If file mode is write operation #
            else:
                # If there is no data to write #
                if not data:
                    # Print error, log, and exit #
                    print_err(f'Attempting to write to {file_path.name} with no data')
                    logging.error('Attempting to write to %s with no data\n\n', file_path.name)
                    sys.exit(6)

                # If attempting to overwrite yaml config file #
                if yaml:
                    # Print error, log, and exit #
                    print_err('Attempted to write to YAML configuration file')
                    logging.error('Attempted to write to YAML configuration file')
                    sys.exit(7)

                file.write(data)

            # Follows pylint return all or nothing rule #
            return None

    # If error occurs during file operation #
    except (IOError, OSError) as err:
        # Look up file error based on low-level descriptor #
        error_query(str(file_path.resolve()), mode, err)


def print_err(msg: str):
    """
    Displays the error message through stderr (standard error).

    :param msg:  The error message to be displayed.
    :return:  Nothing
    """
    print(f'\n* [ERROR] {msg} *\n', file=sys.stderr)


class ScanClass:
    func_dict = {
        # TCP handler functions #
        '20,21': ftp_handler,
        '22': ssh_handler,
        '23': telnet_handler,
        '25,465,587,2525': smtp_handler,
        '79': finger_handler,
        '80,443,8080,8443': web_handler,
        '110,995': pop3_handler,
        '119,433': nntp_handler,
        '143,993': imap_handler,
        '199': smux_handler,
        '445': smb_handler,
        '554': rtsp_handler,
        '631': cups_handler,
        '749': kerbv5_admin_tcp_handler,
        '761': kerbv4_passwd_tcp_handler,
        '873': rsync_handler,
        '1025': iis_handler,
        '1433': mssql_handler,
        '1521': oracle_db_handler,
        '2100': oracle_xmldb_handler,
        '3306': sql_handler,
        '3339': oracle_web_handler,
        '3389': rdp_handler,
        '5037,5555': adb_handler,
        '5800,5900': vnc_handler,
        '5985,5986': winrm_handler,
        '9389': ad_admin_handler,

        # UDP handler functions #
        '67': dhcp_handler,
        '69': tftp_handler,
        '464': kerbv5_passwd_udp_handler,
        '4444': kerbv5_ticket_udp_handler,
        '5353': mdns_handler,

        # TCP/UDP handler functions #
        '42': wins_handler,
        '53': dns_handler,
        '88': kerbv5_ticket_handler,
        '111': rpc_handler,
        '123': ntp_handler,
        '135': msrpc_handler,
        '137': netbios_name_handler,
        '139': netbios_sesh_handler,
        '161,162,10161,10162': snmp_handler,
        '389,636': ldap_handler,
        '750': kerbv4_ticket_handler,
        '751': kerbv4_admin_handler,
        '1030,1032,1033,1038': windomain_handler,
        '1748,1754,1808,1809': oracle_agent_handler,
        '2049': nfs_handler,
        '3268,3269': globalcat_ldap_handler,
        '4445': upnotifyp_handler,
        '4555': rsip_handler,
        '5357': wsdapi_handler,
        '5722': dfsr_handler,
        '47001': wrms_handler
    }


def system_cmd(cmd: str, stdout, stderr, exec_time: int, out_file=None):
    """
    Executes shell-escaped system command with the ability to redirect output to a file for
    generating scan reports.

    :param cmd:  The command to be executed.
    :param stdout:  The child process standard output.
    :param stderr:  The child process standard error.
    :param exec_time:  The execution timeout to prevent process hangs.
    :param out_file:  The output file where the results are stored.
    :return:  Nothing
    """
    # Shell escape command string #
    exe = shlex.quote(cmd)
    command = None

    try:
        # If the output is to be written to a file #
        if out_file:
            # Create output file in write mode #
            with open(out_file, 'w') as file:
                # TODO use the log file as stderr
                command = Popen(exe, stdout=file, stderr=stderr, shell=False)
                command.communicate(timeout=exec_time)
        # If the command is executed without file redirect #
        else:
            command = Popen(exe, stdout=stdout, stderr=stderr, shell=False)
            command.communicate(timeout=exec_time)

    # If error occurs during file operation #
    except (IOError, OSError) as file_err:
        error_query(str(out_file.resolve()), 'w', file_err)

    # Handles process timeouts and errors #
    except (SubprocessError, TimeoutExpired, CalledProcessError, OSError, ValueError) as proc_err:
        command.kill()
        command.communicate()

        # If error is of significance (non-timeout) #
        if not TimeoutExpired:
            print_err(f'Error occurred during child process execution: {proc_err}')
            logging.exception('Error occurred during child process execution: %s\n\n', proc_err)
            sys.exit(7)
