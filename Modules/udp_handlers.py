""" Built-in modules """
import logging
# Custom modules #
from Modules.utils import cmd_parser, file_handler, system_cmd


def dhcp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the dhcp out file path #
    dhcp_path = paths[2] / 'dhcp_out.txt'

    # Iterate through dhcp commands from yaml file #
    for command in (config.dhcp + config.dhcp_custom):
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # If the command is based on system path #
        if command not in config.dhcp_custom:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1])
        # If the command is a program in set custom programs folder #
        else:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1], is_custom=True)

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{command}\n{"*" * (len(command) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(dhcp_path, 'a', log_tuple[1], data=data)


def tftp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the tftp output file path #
    tftp_path = paths[2] / 'tftp_out.txt'

    # Iterate through tftp commands from yaml file #
    for command in (config.tftp + config.tftp_custom):
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # If the command is based on system path #
        if command not in config.tftp_custom:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1])
        # If the command is a program in set custom programs folder #
        else:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1], is_custom=True)

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{command}\n{"*" * (len(command) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(tftp_path, 'a', log_tuple[1], data=data)


def kerbv5_passwd_udp_handler(ip_addr: str, paths: tuple, port_num: int, config: object,
                              re_obj:object, log_tuple: tuple):
    # Set the kerberos v5 passwd udp output file path #
    kerbv5_passwd_udp_path = paths[2] / 'kerbv5_passwd_udp_out.txt'

    # Iterate through kerberos v5 passwd udp commands from yaml file #
    for command in (config.kerberos_v5_passwd_udp + config.kerberos_v5_passwd_udp_custom):
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # If the command is based on system path #
        if command not in config.kerberos_v5_passwd_udp_custom:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1])
        # If the command is a program in set custom programs folder #
        else:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1], is_custom=True)

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{command}\n{"*" * (len(command) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(kerbv5_passwd_udp_path, 'a', log_tuple[1], data=data)


def kerbv5_ticket_udp_handler(ip_addr: str, paths: tuple, port_num: int, config: object,
                              re_obj: object, log_tuple: tuple):
    # Set the kerberos v5 ticket udp output file path #
    kerbv5_ticket_udp_path = paths[2] / 'kerbv5_ticket_udp_out.txt'

    # Iterate through kerberos v5 ticket udp commands from yaml file #
    for command in (config.kerberos_v5_ticket_udp + config.kerberos_v5_ticket_udp_custom):
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # If the command is based on system path #
        if command not in config.kerberos_v5_ticket_udp_custom:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1])
        # If the command is a program in set custom programs folder #
        else:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1], is_custom=True)

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{command}\n{"*" * (len(command) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(kerbv5_ticket_udp_path, 'a', log_tuple[1], data=data)


def mdns_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the mdns output file path #
    mdns_path = paths[2] / 'mdns_out.txt'

    # Iterate through mdns commands from yaml file #
    for command in (config.mdns + config.mdns_custom):
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # If the command is based on system path #
        if command not in config.mdns_custom:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1])
        # If the command is a program in set custom programs folder #
        else:
            # Execute system command #
            output = system_cmd(command, None, config, log_tuple[1], is_custom=True)

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{command}\n{"*" * (len(command) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(mdns_path, 'a', log_tuple[1], data=data)
