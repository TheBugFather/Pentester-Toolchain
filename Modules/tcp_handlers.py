""" Built-in modules """
import logging
# Custom modules #
from Modules.utils import cmd_parser, file_handler, system_cmd


def ftp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the ftp output file path #
    ftp_path = paths[1] / 'ftp_out.txt'

    # Iterate through ftp commands from yaml file #
    for command in config.ftp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(ftp_path, 'a', log_tuple[1], data=data)


def ssh_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the ssh output file path #
    ssh_path = paths[1] / 'ssh_out.txt'

    # Iterate through ssh commands from yaml file #
    for command in config.ssh:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(ssh_path, 'a', log_tuple[1], data=data)


def telnet_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                   log_tuple: tuple):
    # Set the telnet output file path #
    telnet_path = paths[1] / 'telnet_out.txt'

    # Iterate through telnet commands from yaml file #
    for command in config.telnet:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(telnet_path, 'a', log_tuple[1], data=data)


def smtp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the smtp output file path #
    smtp_path = paths[1] / 'smtp_out.txt'

    # Iterate through smtp commands from yaml file #
    for command in config.smtp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(smtp_path, 'a', log_tuple[1], data=data)


def finger_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                   log_tuple: tuple):
    # Set the finger output file path #
    finger_path = paths[1] / 'finger_out.txt'

    # Iterate through finger commands from yaml file #
    for command in config.finger:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(finger_path, 'a', log_tuple[1], data=data)


def web_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the web output file path #
    web_path = paths[1] / 'web_out.txt'

    # Iterate through web commands from yaml file #
    for command in config.web:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(web_path, 'a', log_tuple[1], data=data)


def pop3_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the pop3 output file path #
    pop3_path = paths[1] / 'pop3_out.txt'

    # Iterate through pop3 commands from yaml file #
    for command in config.pop3:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(pop3_path, 'a', log_tuple[1], data=data)


def nntp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the nntp output file path #
    nntp_path = paths[1] / 'nntp_out.txt'

    # Iterate through nntp commands from yaml file #
    for command in config.nntp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(nntp_path, 'a', log_tuple[1], data=data)


def imap_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the imap output file path #
    imap_path = paths[1] / 'imap_out.txt'

    # Iterate through imap commands from yaml file #
    for command in config.imap:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(imap_path, 'a', log_tuple[1], data=data)


def smux_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the smux output file path #
    smux_path = paths[1] / 'smux_out.txt'

    # Iterate through smux commands from yaml file #
    for command in config.smux:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(smux_path, 'a', log_tuple[1], data=data)


def smb_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the smb output file path #
    smb_path = paths[1] / 'smb_out.txt'

    # Iterate through smb commands from yaml file #
    for command in config.smb:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(smb_path, 'a', log_tuple[1], data=data)


def rtsp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the rtsp output file path #
    rtsp_path = paths[1] / 'rtsp_out.txt'

    # Iterate through rtsp commands from yaml file #
    for command in config.rtsp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(rtsp_path, 'a', log_tuple[1], data=data)


def cups_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                 log_tuple: tuple):
    # Set the cups output file path #
    cups_path = paths[1] / 'cups_out.txt'

    # Iterate through cups commands from yaml file #
    for command in config.cups:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(cups_path, 'a', log_tuple[1], data=data)


def kerbv5_admin_tcp_handler(ip_addr: str, paths: tuple, port_num: int, config: object,
                             re_obj: object, log_tuple: tuple):
    # Set the kerberos v5 admin tcp output file path #
    kerbv5_admin_tcp_path = paths[1] / 'kerbv5_admin_tcp_out.txt'

    # Iterate through kerberos v5 admin tcp commands from yaml file #
    for command in config.kerberos_v5_admin_tcp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(kerbv5_admin_tcp_path, 'a', log_tuple[1], data=data)


def kerbv4_passwd_tcp_handler(ip_addr: str, paths: tuple, port_num: int, config: object,
                              re_obj: object, log_tuple: tuple):
    # Set the kerberos v5 passwd tcp output file path #
    kerbv4_passwd_tcp_path = paths[1] / 'kerbv4_passwd_tcp_out.txt'

    # Iterate through kerberos v4 passwd tcp commands from yaml file #
    for command in config.kerberos_v4_passwd_tcp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(kerbv4_passwd_tcp_path, 'a', log_tuple[1], data=data)


def rsync_handler(ip_addr: str, paths: tuple, port_num: int, config: object,
                  re_obj: object, log_tuple: tuple):
    # Set the rsync output file path #
    rsync_path = paths[1] / 'rsync_out.txt'

    # Iterate through rsync commands from yaml file #
    for command in config.rsync:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(rsync_path, 'a', log_tuple[1], data=data)


def iis_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the iis output file path #
    iis_path = paths[1] / 'iis_out.txt'

    # Iterate through iss commands from yaml file #
    for command in config.iss:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(iis_path, 'a', log_tuple[1], data=data)


def mssql_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                  log_tuple: tuple):
    # Set the mssql output file path #
    mssql_path = paths[1] / 'mssql_out.txt'

    # Iterate through mssql commands from yaml file #
    for command in config.mssql:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(mssql_path, 'a', log_tuple[1], data=data)


def oracle_db_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                      log_tuple: tuple):
    # Set the oracle db output file path #
    oracle_db_path = paths[1] / 'oracle_db_out.txt'

    # Iterate through oracle db commands from yaml file #
    for command in config.oracle_db:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(oracle_db_path, 'a', log_tuple[1], data=data)


def oracle_xmldb_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                         log_tuple: tuple):
    # Set the oracle xml db output file path #
    oracle_xmldb_path = paths[1] / 'oracle_xmldb_out.txt'

    # Iterate through oracle xml db commands from yaml file #
    for command in config.oracle_xml_db:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(oracle_xmldb_path, 'a', log_tuple[1], data=data)


def sql_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the sql output file path #
    sql_path = paths[1] / 'sql_out.txt'

    # Iterate through sql commands from yaml file #
    for command in config.sql:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(sql_path, 'a', log_tuple[1], data=data)


def oracle_web_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                       log_tuple: tuple):
    # Set the oracle web output file path #
    oracle_web_path = paths[1] / 'oracle_web_out.txt'

    # Iterate through oracle web commands from yaml file #
    for command in config.oracle_web:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(oracle_web_path, 'a', log_tuple[1], data=data)


def rdp_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the rdp output file path #
    rdp_path = paths[1] / 'rdp_out.txt'

    # Iterate through rdp commands from yaml file #
    for command in config.rdp:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(rdp_path, 'a', log_tuple[1], data=data)


def adb_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the adb output file path #
    adb_path = paths[1] / 'adb_out.txt'

    # Iterate through adb commands from yaml file #
    for command in config.adb:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(adb_path, 'a', log_tuple[1], data=data)


def vnc_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                log_tuple: tuple):
    # Set the vnc output file path #
    vnc_path = paths[1] / 'vnc_out.txt'

    # Iterate through vnc commands from yaml file #
    for command in config.vnc:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(vnc_path, 'a', log_tuple[1], data=data)


def winrm_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                  log_tuple: tuple):
    # Set the winrm output file path #
    winrm_path = paths[1] / 'winrm_out.txt'

    # Iterate through winrm commands from yaml file #
    for command in config.winrm:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(winrm_path, 'a', log_tuple[1], data=data)


def ad_admin_handler(ip_addr: str, paths: tuple, port_num: int, config: object, re_obj: object,
                     log_tuple: tuple):
    # Set the ad admin output file path #
    ad_admin_path = paths[1] / 'ad_admin_out.txt'

    # Iterate through ad admin center commands from yaml file #
    for command in config.adac:
        # Check to see if command has delimiter to parse #
        args = [True if delimiter in command else False for delimiter in config.delimiters]

        # If args are to be parsed in command #
        if True in args:
            # Parse in args and split into list #
            command = cmd_parser(command, re_obj, ip_addr, port_num)

        # Execute system command #
        output = system_cmd(command, None, config, log_tuple[1])

        # If the command return data #
        if output:
            # Split command into list to grab name #
            cmd_list = command.split()
            log_tuple[0].log(logging.INFO, '[+] Executing %s on %s', cmd_list[0], ip_addr)
            data = f'{cmd_list[0]}\n{"*" * (len(cmd_list[0]) + 1)}\n{output.decode()}\n\n'
            # Write the output with command title to service file #
            file_handler(ad_admin_path, 'a', log_tuple[1], data=data)
